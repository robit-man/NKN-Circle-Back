<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>NKN Mesh — Multi-Peer Video (Mobile-First, Click-to-Stream)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://unpkg.com/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
  <style>
    :root {
      --bg: #0b0b0b;
      --fg: #eee;
      --muted: #9aa0a6;
      --line: #1b1b1b;
      --ok: #30cf6b;
      --warn: #f7b500;
      --err: #e84d4d;
      --card: #0f1011;
      --chip: #0a0a0a;
      --accent: #3b82f6;
      --frame: #000;
    }

    * {
      box-sizing: border-box
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, sans-serif
    }

    /* Header */
    .bar {
      position: sticky;
      top: 0;
      width: 100vw;
      z-index: 30;
      display: flex;
      flex-flow: row;
      overflow-x: auto;
      align-items: center;
      gap: 10px;
      box-sizing: border-box;
      padding: 10px 12px;
      background: rgba(10, 10, 10, .9);
      backdrop-filter: saturate(1.2) blur(6px);
      border-bottom: 1px solid var(--line);
    }

    .bar h1 {
      margin: 0;
      font-size: 16px
    }

    .grow {
      flex: 1
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace
    }

    .tiny {
      font-size: 12px;
      color: var(--muted)
    }

    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #444;
      border: 1px solid #222;
      display: inline-block
    }

    .ok {
      background: var(--ok)
    }

    .warn {
      background: var(--warn)
    }

    .err {
      background: var(--err)
    }

    @keyframes nknTxBlink {

      0%,
      55% {
        opacity: 1
      }

      55%,
      100% {
        opacity: .35
      }
    }

    .dot.ok.blink {
      animation: nknTxBlink 1s linear infinite;
    }

    .kv {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      background: #0a0a0a;
      border: 1px solid #222;
      border-radius: 8px;
      padding: 3px 8px
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid #252525;
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 12px;
      background: #0a0a0a
    }

    /* Sidebar */
    .sideToggle {
      appearance: none;
      border: 1px solid #333;
      background: #111;
      color: #fff;
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      z-index: 2;
    }

    .sidebar {
      position: absolute;
      inset: 0 auto 0 0;
      width: min(90vw, 360px);
      transform: translateX(-100%);
      transition: transform .25s ease;
      background: var(--card);
      border-right: 1px solid #1b1b1b;
      z-index: 50;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 12px;
      overflow-x: clip;
      overflow-y: auto;
      padding: 12px;
      top: 54px;
      max-height: calc(100vh - 54px);
    }

    .backToggle {
      display: flex;
      height: 100vh;
      width: 100vw;
      position: fixed;
      z-index: 1;
      backdrop-filter: blur(20px);
      transform: translateX(-100%);
    }

    .backToggle.open {
      transform: none;
    }

    .sidebar.open {
      transform: none
    }

    .sideSection {
      border: 1px solid #1d1d1d;
      border-radius: 12px;
      padding: 10px;
      background: #101113
    }

    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin: 8px 0 6px
    }

    input[type="text"],
    select {
      width: 100%;
      height: 36px;
      background: #000;
      border: 1px solid #242424;
      border-radius: 10px;
      color: var(--fg);
      padding: 8px 10px
    }

    input[type="range"] {
      width: 100%
    }

    /* Content */
    .wrap {
      max-width: 1400px;
      margin: 0 auto;
      padding: 10px
    }

    .wrap-bar {
      display: flex;
      flex-flow: row;
      gap: 10px;
    }

    #grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
    }

    /* Peer tile */
    .peer {
      border: 1px solid #1b1b1b;
      border-radius: 12px;
      overflow: hidden;
      background: #0b0c0d;
    }

    .frame {
      position: relative;
      background: var(--frame);
      border-bottom: 1px solid #161616;
      aspect-ratio: 4/3;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      cursor: pointer;
    }

    .frame:active {
      transform: translateY(1px)
    }

    .preview {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000
    }

    .preview canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover
    }

    .overlay {
      position: absolute;
      left: 8px;
      right: 8px;
      display: flex;
      align-items: center;
      pointer-events: none;
      gap: 6px;
      font-size: 12px;
    }

    .overlay.top {
      top: 8px;
      justify-content: space-between
    }

    .overlay.bottom {
      bottom: 8px;
      justify-content: flex-start;
      color: #ddd
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid #222;
      background: #0a0a0a
    }

    .tx {
      font-weight: 600;
      border-color: #2a2a2a
    }

    .addr {
      font-weight: 600
    }

    .meta {
      font-size: 11px;
      color: var(--muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px
    }

    .row.head {
      justify-content: space-between
    }

    .name {
      font-weight: 600
    }

    .muted {
      color: var(--muted)
    }

    /* Self tile (optional) */
    .self .overlay.top .addr::after {
      content: " (you)";
      font-weight: 400;
      color: var(--muted);
    }

    /* Status chips in header */
    .status {
      display: flex;
      flex-flow: row;
      overflow-x: auto;
      gap: 8px;
      align-items: center;
      width: max-content;
    }

    .hideme {
      display: none
    }

    @media (min-width: 920px) {
      #grid {
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
        gap: 12px
      }
    }
  </style>
</head>

<body>
  <!-- Header -->
  <div class="bar">
    <div class="wrap-bar">
      <button id="btnSide" class="sideToggle">☰</button>
      <div class="grow"></div>
      <div class="status tiny">
        <span class="kv"><span id="txtNkn">NKN: connecting…</span><span id="dotNkn" class="dot"></span></span>
        <span class="kv"><span id="txtSig">Mesh: discovering…</span><span id="dotSig" class="dot"></span></span>
        <span id="txtSigMeta" class="tiny">—</span>
      </div>
    </div>
  </div>

  <!-- Sidebar (hidden controls) -->
  <aside id="sidebar" class="sidebar">
    <div class="sideSection">
      <div class="row head">
        <div class="badge">Local Video</div>
        <div class="tiny">Your addr: <span id="myAddr" class="mono">—</span></div>
      </div>
      <video id="localVideo" muted playsinline autoplay
        style="width:100%;border:1px solid #222;border-radius:10px;background:#000;max-height:180px;object-fit:cover"></video>
      <div class="row" style="flex-wrap:wrap">
        <span class="kv"><span>Src FPS</span><strong id="mFps">—</strong></span>
        <span class="kv"><span>Avg KB</span><strong id="mSize">—</strong></span>
        <span class="kv"><span>Sent</span><strong id="mSent">0</strong></span>
        <span class="kv"><span>Dropped</span><strong id="mDrop">0</strong></span>
      </div>
    </div>

    <div class="sideSection">
      <label>Primary Signaller Public Key (64-hex) — override</label>
      <input id="hexSig" class="mono" placeholder="64-hex (blank = default)" spellcheck="false" />
      <div class="tiny">Default: <code
          class="mono">5a0a81a8e4d6538a81e59d04057611a779f762da49c5eaf79a96badb91788c0c</code></div>
    </div>

    <div class="sideSection">
      <div class="badge">Encoder & Delivery</div>
      <label>Target FPS</label>
      <input id="fpsSlider" type="range" min="4" max="30" step="1" value="25" />
      <div class="tiny"><span id="fpsLbl">25</span> fps (global cadence)</div>

      <label>Scale (downsize)</label>
      <input id="sSlider" type="range" min="0.4" max="1.0" step="0.05" value="0.5" />
      <div class="tiny">Lower = fewer pixels</div>

      <label>Quality</label>
      <select id="fmtQ">
        <option value="jpeg:0.60" selected>JPEG 0.60</option>
        <option value="jpeg:0.70">JPEG 0.70</option>
        <option value="webp:0.60">WebP 0.60</option>
        <option value="webp:0.70">WebP 0.70</option>
      </select>

      <label>Max KB / frame</label>
      <input id="kbSlider" type="range" min="80" max="900" step="20" value="380" />
      <div class="tiny"><span id="kbLbl">380</span> KB cap</div>

      <label>Realtime Bias (latency ⇄ quality)</label>
      <input id="biasSlider" type="range" min="0" max="1" step="0.05" value="0.7" />
      <div class="tiny">Higher = prefer lower delay, pace per-peer when E2E rises</div>
    </div>
  </aside>

  </button>

  <!-- Grid -->
  <div class="wrap">
    <div id="grid"></div>
  </div>

  <script>
    /* ====== helpers ====== */
    const $ = s => document.querySelector(s);
    const shortHex = (s, a = 8, b = 6) => s ? (s.slice(0, a) + '…' + s.slice(-b)) : '—';
    const isHex64 = s => /^[0-9a-f]{64}$/i.test((s || '').trim());
    const now = () => Date.now();
    const fmtAgo = ms => { if (ms < 1500) return 'now'; const s = Math.floor(ms / 1000); if (s < 60) return s + 's'; const m = Math.floor(s / 60); if (m < 60) return m + 'm'; const h = Math.floor(m / 60); if (h < 24) return h + 'h'; const d = Math.floor(h / 24); return d + 'd'; };
    const setNkn = (t, cls) => { $('#txtNkn').textContent = t; $('#dotNkn').className = 'dot ' + (cls || ''); };
    const setSig = (t, cls) => { $('#txtSig').textContent = t; $('#dotSig').className = 'dot ' + (cls || ''); };
    const setSigMeta = t => { $('#txtSigMeta').textContent = t; };

    const LS = { SEED: 'NKN_SEED_HEX_V1', SIGHEX: 'NKN_SIG_HEX', KNOWN_IDS: 'NKN_KNOWN_IDS_V2' };
    const DEFAULT_SIG_HEX = '5a0a81a8e4d6538a81e59d04057611a779f762da49c5eaf79a96badb91788c0c';
    const toHex = u8 => Array.from(u8).map(b => b.toString(16).padStart(2, '0')).join('');
    function getOrCreateSeed() { let hex = localStorage.getItem(LS.SEED); if (/^[0-9a-f]{64}$/i.test(hex || '')) return hex; const u = new Uint8Array(32); crypto.getRandomValues(u); hex = toHex(u); localStorage.setItem(LS.SEED, hex); return hex; }

    /* ====== layout / sidebar ====== */
    const sidebar = $('#sidebar');
    const btnback = $('#btnBack');
    $('#btnSide').addEventListener('click', () => sidebar.classList.toggle('open'));
    $('#btnSide').addEventListener('click', () => btnback.classList.toggle('open'));

    /* ====== mesh / peer state ====== */
    let client = null, selfPub = null, selfAddr = null;
    let signallerHex = '', signallerPrefix = 'signal';

    const peers = new Map(); // pub -> {addr,lastTs,isVestigial}
    const knownIdsByPub = new Map(); const idSet = (pub) => { let s = knownIdsByPub.get(pub); if (!s) { s = new Set(['peer', 'web', 'signal']); knownIdsByPub.set(pub, s); } return s; };
    (function loadKnownIds() { try { const t = localStorage.getItem(LS.KNOWN_IDS); if (!t) return; const j = JSON.parse(t); for (const [k, arr] of Object.entries(j)) knownIdsByPub.set(k, new Set(arr)); } catch { } })();
    const persistKnownIds = () => { const obj = {}; for (const [k, set] of knownIdsByPub.entries()) obj[k] = [...set]; localStorage.setItem(LS.KNOWN_IDS, JSON.stringify(obj)); };

    const addrPool = new Map(); // addr -> {lastSeen,lastAck,rttMs,updates,failures,lastProbe}
    const lastLive = (m) => Math.max(m?.lastAck || 0, m?.lastSeen || 0);
    function poolAdd(addr, when = now()) { if (!addr) return; const m = addrPool.get(addr) || { lastSeen: 0, lastAck: 0, rttMs: null, updates: 0, failures: 0, lastProbe: 0 }; m.lastSeen = Math.max(m.lastSeen, when); addrPool.set(addr, m); updateSigMeta(); }
    function poolNoteAck(addr, rtt = null) { const m = addrPool.get(addr) || { lastSeen: 0, lastAck: 0, rttMs: null, updates: 0, failures: 0, lastProbe: 0 }; m.lastAck = now(); if (rtt != null) m.rttMs = rtt; addrPool.set(addr, m); updateSigMeta(); }
    function poolNoteUpdate(addr) { const m = addrPool.get(addr) || { lastSeen: 0, lastAck: 0, rttMs: null, updates: 0, failures: 0, lastProbe: 0 }; m.lastSeen = now(); m.updates += 1; addrPool.set(addr, m); updateSigMeta(); }
    function isPeerOnline(pub) { return addressesForPub(pub).some(a => (now() - (addrPool.get(a)?.lastAck || addrPool.get(a)?.lastSeen || 0)) < 45000); }
    function onlineCount() { let n = 0; for (const [addr, m] of addrPool.entries()) if ((now() - (m.lastAck || m.lastSeen || 0)) < 15000) n++; return n; }
    function updateSigMeta() {
      let best = null, bRtt = Infinity, bSeen = 0;
      for (const [addr, m] of addrPool.entries()) {
        const r = m.rttMs == null ? Infinity : m.rttMs; const s = Math.max(m.lastAck || 0, m.lastSeen || 0);
        if (r < bRtt || (r === bRtt && s > bSeen)) { best = addr; bRtt = r; bSeen = s; }
      }
      const live = onlineCount(), total = addrPool.size;
      if (!best) { setSig('Mesh: discovering…', 'warn'); setSigMeta(`targets: ${total} • online: ${live} • latency: —`); }
      else { const lastSeenStr = bSeen ? `${fmtAgo(now() - bSeen)} ago` : '—'; const rtt = (bRtt === Infinity) ? '—' : `${Math.round(bRtt)} ms`; setSig(`Mesh: ${shortHex(best, 7, 6)} • ${live}/${total} online`, 'ok'); setSigMeta(`last seen: ${lastSeenStr} • latency: ${rtt}`); }
    }

    function ensurePeer(pub, { addr = null, ts = now(), vestigial = false } = {}) { const p = (peers.get(pub) || { addr: null, lastTs: 0, isVestigial: false }); if (addr) p.addr = addr; if (ts > (p.lastTs || 0)) p.lastTs = ts; p.isVestigial = !!vestigial; peers.set(pub, p); ensurePeerTile(pub); updatePeerUI(pub); }

    function addressesForPub(pub) { const ids = idSet(pub); const set = new Set(); const ent = peers.get(pub); if (ent?.addr) set.add(ent.addr); ids.forEach(id => set.add(`${id}.${pub}`)); return [...set]; }
    function bestAddrForPub(pub) {
      const list = addressesForPub(pub);
      let best = null, bRtt = Infinity, bSeen = 0;
      for (const a of list) { const m = addrPool.get(a) || {}; const r = (m.rttMs == null) ? Infinity : m.rttMs; const s = Math.max(m.lastAck || 0, m.lastSeen || 0); if (r < bRtt || (r === bRtt && s > bSeen)) { best = a; bRtt = r; bSeen = s; } }
      return best || list[0];
    }

    /* ====== HB / roster ====== */
    let hbTimer = null, tickTimer = null;
    function targets(max = 200) {
      const set = new Set();
      if (isHex64(signallerHex)) set.add(`${signallerPrefix}.${signallerHex}`);
      for (const a of addrPool.keys()) set.add(a);
      for (const [pub, ent] of peers.entries()) {
        if (ent.addr) set.add(ent.addr);
        idSet(pub).forEach(id => set.add(`${id}.${pub}`));
      }
      const out = []; for (const a of set.values()) { if (a !== selfAddr) out.push(a); if (out.length >= max) break; } return out;
    }
    function probeAll() {
      if (!client || !client.addr || !selfPub) return;
      const list = targets(); const t0 = now();
      for (const to of list) {
        const id = `hb|${selfPub}|${t0}|${to}`;
        const m = addrPool.get(to) || {}; m.lastProbe = t0; addrPool.set(to, m);
        rawSend(to, JSON.stringify({ ver: 1, type: 'hb', id, from: selfPub, t_client: t0, caps: { relay: true, roster: true } })).catch(() => { });
        rawSend(to, JSON.stringify({ ver: 1, type: 'peers_req', id: `peers_req|${selfPub}|${t0}`, from: selfPub, ts: t0 })).catch(() => { });
      }
    }
    function scheduleHB() { if (hbTimer) clearInterval(hbTimer); hbTimer = setInterval(probeAll, 12000); }
    function scheduleTicks() {
      if (tickTimer) clearInterval(tickTimer); tickTimer = setInterval(() => {
        const t = now(); for (const [addr, m] of addrPool.entries()) { if ((t - Math.max(m.lastSeen || 0, m.lastAck || 0)) < 60000) { rawSend(addr, JSON.stringify({ ver: 1, type: 'tick', id: `tick|${selfPub}|${t}|${addr}`, from: selfPub, ts: t })).catch(() => { }); } }
      }, 5000);
    }

    /* ====== NKN send helpers ====== */
    let SEND_OPTS = { noReply: true, maxHoldingSeconds: 0 }; // drop vs queue → lower latency
    async function rawSend(to, payload) { try { return await client.send(to, payload, SEND_OPTS); } catch (e) { throw e; } }
    async function sendToBest(pub, payload) {
      const list = addressesForPub(pub).sort((a, b) => {
        const ma = addrPool.get(a) || {}, mb = addrPool.get(b) || {};
        const ra = ma.rttMs == null ? 1e12 : ma.rttMs, rb = mb.rttMs == null ? 1e12 : mb.rttMs;
        if (ra !== rb) return ra - rb;
        return (Math.max(mb.lastAck || 0, mb.lastSeen || 0)) - (Math.max(ma.lastAck || 0, ma.lastSeen || 0));
      });
      for (const to of list) { try { await rawSend(to, payload); return true; } catch { } }
      if (isHex64(signallerHex)) { try { await rawSend(`${signallerPrefix}.${signallerHex}`, payload); return true; } catch { } }
      return false;
    }

    /* ====== local camera + VF2 encoder ====== */
    const localVideo = $('#localVideo'), fpsSlider = $('#fpsSlider'), sSlider = $('#sSlider'), fmtQ = $('#fmtQ'), kbSlider = $('#kbSlider'), biasSlider = $('#biasSlider');
    const fpsLbl = $('#fpsLbl'), kbLbl = $('#kbLbl');
    fpsSlider?.addEventListener('input', () => fpsLbl.textContent = fpsSlider.value);
    kbSlider?.addEventListener('input', () => kbLbl.textContent = kbSlider.value);

    const mFps = $('#mFps'), mSize = $('#mSize'), mSent = $('#mSent'), mDrop = $('#mDrop');
    let srcFpsCount = 0, totalSent = 0, totalDropped = 0, sizeEMA = null;
    setInterval(() => { if (mFps) mFps.textContent = String(srcFpsCount); srcFpsCount = 0; if (mSize) mSize.textContent = sizeEMA ? Math.round(sizeEMA / 1024) + ' KB' : '—'; if (mSent) mSent.textContent = String(totalSent); if (mDrop) mDrop.textContent = String(totalDropped); }, 1000);

    // --- Camera facing toggle (front/back) ---------------------------------------
    let CAM_FACING = localStorage.getItem('NKN_CAM_FACING') || 'user';

    async function restartLocalCamera() {
      // stop old tracks (if any)
      try {
        const old = localVideo?.srcObject;
        if (old) [...old.getVideoTracks(), ...old.getAudioTracks()].forEach(t => t.stop());
      } catch {}

      // try exact, then ideal, then fallback without facingMode
      const base = { width:{ideal:640}, height:{ideal:480}, frameRate:{ideal:30,max:30} };
      const tries = [
        { video: { ...base, facingMode: { exact: CAM_FACING } }, audio: false },
        { video: { ...base, facingMode: CAM_FACING },            audio: false },
        { video: { ...base },                                    audio: false }
      ];

      let stream = null, lastErr = null;
      for (const c of tries) {
        try { stream = await navigator.mediaDevices.getUserMedia(c); break; }
        catch (e) { lastErr = e; }
      }
      if (!stream) throw lastErr || new Error('getUserMedia failed');

      if (localVideo) {
        localVideo.srcObject = stream;
        try { await localVideo.play(); } catch {}
      }

      // keep self-tile preview in sync
      const ghost = document.querySelector('.peer.self .preview video');
      if (ghost) {
        ghost.srcObject = stream;
        try { await ghost.play(); } catch {}
      }
    }

    async function toggleFacing() {
      CAM_FACING = (CAM_FACING === 'user') ? 'environment' : 'user';
      localStorage.setItem('NKN_CAM_FACING', CAM_FACING);
      await restartLocalCamera();  // encoder keeps running; canvas picks up new frames
    }


    async function ensureCamStream(){
      if (localVideo?.srcObject) return localVideo.srcObject;
      await restartLocalCamera();        // respects CAM_FACING from step 1
      startGlobalEncoder();              // kick encoder once
      return localVideo.srcObject;
    }

    let encCanvas = null, encCtx = null, encRAF = null, lastEncAt = 0, latestVF2 = null;
    // VF2 header: 18 bytes (MAGIC + meta) + payload
    const VF2 = {
      MAGIC0: 0x56, MAGIC1: 0x46, MAGIC2: 0x32, VER: 1,
      FMT_JPEG: 1, FMT_WEBP: 2,
      pack({ fmtCode, w, h, ts, seq, bytesU8 }) {
        const out = new Uint8Array(18 + bytesU8.byteLength);
        out[0] = this.MAGIC0; out[1] = this.MAGIC1; out[2] = this.MAGIC2; out[3] = this.VER;
        out[4] = fmtCode; out[5] = 0; // flags
        const dv = new DataView(out.buffer, out.byteOffset, out.byteLength);
        dv.setUint16(6, w, false); dv.setUint16(8, h, false);
        dv.setUint32(10, ts >>> 0, false);
        dv.setUint32(14, seq >>> 0, false);
        out.set(bytesU8, 18);
        return out;
      },
      parse(u8) {
        if (!u8 || u8.length < 18) return null;
        if (u8[0] !== this.MAGIC0 || u8[1] !== this.MAGIC1 || u8[2] !== this.MAGIC2) return null;
        const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
        const ver = u8[3]; if (ver !== this.VER) return null;
        const fmtCode = u8[4];
        const w = dv.getUint16(6, false), h = dv.getUint16(8, false);
        const ts = dv.getUint32(10, false), seq = dv.getUint32(14, false);
        const payload = u8.subarray(18);
        return { fmtCode, w, h, ts, seq, payload };
      },
      mimeFromCode(c) { return c === 1 ? 'image/jpeg' : (c === 2 ? 'image/webp' : 'application/octet-stream'); }
    };

    function startGlobalEncoder() {
      if (encRAF) return;
      encCanvas = document.createElement('canvas');
      encCtx = encCanvas.getContext('2d', { alpha: false, desynchronized: true });

      const encodeOnce = async () => {
        if (!localVideo || localVideo.videoWidth <= 0) return null;
        const scale = parseFloat(sSlider?.value || '0.7');
        const w = Math.max(2, Math.round(localVideo.videoWidth * scale));
        const h = Math.max(2, Math.round(localVideo.videoHeight * scale));
        if (encCanvas.width !== w || encCanvas.height !== h) { encCanvas.width = w; encCanvas.height = h; }
        encCtx.drawImage(localVideo, 0, 0, w, h);

        const [fmt, qStr] = (fmtQ?.value || 'jpeg:0.6').split(':'); const q = parseFloat(qStr || '0.6');
        const mime = (fmt === 'webp') ? 'image/webp' : 'image/jpeg';
        let blob = await new Promise(res => encCanvas.toBlob(res, mime, q));
        const targetKB = parseInt(kbSlider?.value || '380', 10);
        if (blob && blob.size > targetKB * 1024 && q > 0.4) {
          blob = await new Promise(res => encCanvas.toBlob(res, mime, Math.max(0.4, q - 0.1)));
        }
        if (!blob) return null;
        const u8 = new Uint8Array(await blob.arrayBuffer());
        sizeEMA = sizeEMA == null ? u8.byteLength : (0.8 * sizeEMA + 0.2 * u8.byteLength);
        const ts = now(), seq = ts | 0;
        const fmtCode = (mime === 'image/jpeg') ? VF2.FMT_JPEG : VF2.FMT_WEBP;
        const packed = VF2.pack({ fmtCode, w, h, ts, seq, bytesU8: u8 });
        srcFpsCount++;
        return { ts, seq, w, h, bytes: u8.byteLength, packed };
      };

      // Align to real camera frame cadence when available
      const useRVFC = 'requestVideoFrameCallback' in HTMLVideoElement.prototype;
      const stepRAF = async (t) => {
        const targetMs = 1000 / parseInt(fpsSlider?.value || '18', 10);
        if ((t - lastEncAt) >= targetMs) {
          lastEncAt = t;
          const vf2 = await encodeOnce();
          if (vf2) { latestVF2 = vf2; for (const [pub] of streamsOut) sendLatestToPeer(pub); }
        }
        encRAF = requestAnimationFrame(stepRAF);
      };
      const stepRVFC = async () => {
        if (!localVideo?.requestVideoFrameCallback) { stepRAF(0); return; }
        localVideo.requestVideoFrameCallback(async () => {
          const targetMs = 1000 / parseInt(fpsSlider?.value || '18', 10);
          const t = performance.now();
          if ((t - lastEncAt) >= targetMs) {
            lastEncAt = t;
            const vf2 = await encodeOnce();
            if (vf2) { latestVF2 = vf2; for (const [pub] of streamsOut) sendLatestToPeer(pub); }
          }
          stepRVFC();
        });
      };

      if (useRVFC) stepRVFC(); else encRAF = requestAnimationFrame(stepRAF);
    }

    /* ====== per-peer TX state + adaptive pacing ====== */
    const streamsOut = new Map(); // pub -> {inFlight,pending,sent,sizeEMA,ack{winSent,winAck,lastAckAt,e2eEma},fpsTick,txCountSec,txFps,lastSentAt}
    function startStreamingTo(pub) {
      if (streamsOut.has(pub)) return;
      streamsOut.set(pub, { inFlight: false, pending: false, sent: 0, sizeEMA: null, ack: { winSent: 0, winAck: 0, lastAckAt: 0, e2eEma: null }, fpsTick: now(), txCountSec: 0, txFps: 0, lastSentAt: 0 });
      sendToBest(pub, JSON.stringify({ ver: 1, type: 'video_offer', id: `vof|${selfPub}|${now()}`, from: selfPub, to: pub, ts: now() })).catch(() => { });
      sendLatestToPeer(pub); updatePeerUI(pub);
    }
    function stopStreamingTo(pub) { streamsOut.delete(pub); updatePeerUI(pub); }

    function perPeerIntervalMs(pub) {
      const st = streamsOut.get(pub);
      const baseMs = 1000 / parseInt(fpsSlider?.value || '18', 10);
      if (!st || !st.ack) return baseMs;
      const bias = parseFloat(biasSlider?.value || '0.7'); // 0 = ignore e2e, 1 = strongly pace
      const e2e = st.ack.e2eEma ?? 120; // ms
      // Normalize e2e into [0..~1.5] (90ms → 0, 600ms → 1)
      const norm = Math.max(0, Math.min(1.5, (e2e - 90) / 510));
      const factor = 1 + bias * norm; // 1..2.5x
      return baseMs * factor;
    }

    async function sendLatestToPeer(pub) {
      const st = streamsOut.get(pub); if (!st || !latestVF2) return;
      const nowMs = now();
      if (nowMs - st.lastSentAt < perPeerIntervalMs(pub)) { st.pending = true; return; }

      if (st.inFlight) { st.pending = true; return; }
      st.inFlight = true; st.pending = false;

      const payload = latestVF2.packed; // Uint8Array
      const ok = await sendToBest(pub, payload).catch(() => false);
      st.inFlight = false;
      st.lastSentAt = nowMs;

      if (ok) {
        st.sent++; st.ack.winSent++; totalSent++;
        st.sizeEMA = st.sizeEMA == null ? latestVF2.bytes : 0.85 * st.sizeEMA + 0.15 * latestVF2.bytes;
        st.txCountSec++; const t = now(); if (t - st.fpsTick >= 1000) { st.txFps = st.txCountSec; st.txCountSec = 0; st.fpsTick = t; }
      } else {
        totalDropped++;
      }
      if (st.pending) sendLatestToPeer(pub);
      updatePeerUI(pub);
    }

    /* ====== RX sinks + fast decode + ACK ====== */
    const incomingSinks = new Map(); // pub -> {holder,canvas,ctx,w,h}
    function ensureSink(pub) {
      let s = incomingSinks.get(pub);
      const tile = document.querySelector(`.peer[data-pub="${pub}"]`);
      if (!tile) return null;
      let holder = tile.querySelector('.preview');
      if (!holder) { return null; }
      if (s && s.canvas && s.canvas.isConnected) { return s; }
      const c = document.createElement('canvas'); c.width = 320; c.height = 240; const ctx = c.getContext('2d', { alpha: false });
      holder.replaceChildren(c);
      s = { holder, canvas: c, ctx, w: 320, h: 240 }; incomingSinks.set(pub, s); return s;
    }
    function setAspect(holder, w, h) {
      if (holder && 'aspectRatio' in holder.style) holder.style.aspectRatio = `${w} / ${h}`;
    }

    async function decodeU8ToDrawable(u8, mime) {
      try {
        if ('ImageDecoder' in window) {
          const ab = u8.buffer.slice(u8.byteOffset, u8.byteOffset + u8.byteLength);
          const dec = new ImageDecoder({ data: ab, type: mime });
          const { image } = await dec.decode();
          return { type: 'bitmap', bmp: image, w: image.codedWidth || image.displayWidth, h: image.codedHeight || image.displayHeight, close: () => image.close() };
        }
      } catch { }
      try {
        if ('createImageBitmap' in window) {
          const bmp = await createImageBitmap(new Blob([u8], { type: mime }));
          return { type: 'bitmap', bmp, w: bmp.width, h: bmp.height, close: () => bmp.close && bmp.close() };
        }
      } catch { }
      const url = URL.createObjectURL(new Blob([u8], { type: mime }));
      const img = new Image(); img.src = url; await img.decode(); URL.revokeObjectURL(url);
      return { type: 'img', img, w: img.naturalWidth, h: img.naturalHeight, close: () => { } };
    }

    const rxState = new Map(); // pub -> {decoding,queued,lastAckSent,lastSeenSeq,rxFps,rxTick,rxCount}
    async function processQueue(pub) {
      const st = rxState.get(pub) || { decoding: false, queued: null, lastAckSent: 0, lastSeenSeq: 0, rxFps: 0, rxTick: now(), rxCount: 0 };
      if (st.decoding || !st.queued) return;
      st.decoding = true; rxState.set(pub, st);
      const job = st.queued; st.queued = null;
      try {
        const mime = VF2.mimeFromCode(job.fmtCode);
        const drawable = await decodeU8ToDrawable(job.u8, mime);
        const w = job.w || drawable.w, h = job.h || drawable.h;
        const sink = ensureSink(pub); if (!sink) { drawable.close(); st.decoding = false; rxState.set(pub, st); return; }
        setAspect(sink.holder, w, h);
        if (sink.canvas.width !== w || sink.canvas.height !== h) { sink.canvas.width = w; sink.canvas.height = h; }
        if (drawable.type === 'bitmap') sink.ctx.drawImage(drawable.bmp, 0, 0, w, h); else sink.ctx.drawImage(drawable.img, 0, 0, w, h);
        drawable.close();
        st.rxCount++; const t = now(); if (t - st.rxTick >= 1000) { st.rxFps = st.rxCount; st.rxCount = 0; st.rxTick = t; }
      } catch { } finally {
        st.decoding = false; rxState.set(pub, st);
        if (st.queued) processQueue(pub);
      }
      // coalesced ACK by time/seq (tighter for latency)
      st.lastSeenSeq = Math.max(st.lastSeenSeq, job.seq | 0);
      const nowMs = now();
      if (nowMs - (st.lastAckSent || 0) > 120) {
        st.lastAckSent = nowMs;
        sendToBest(pub, JSON.stringify({ ver: 1, type: 'video_ack', id: `vack|${selfPub}|${st.lastSeenSeq}`, from: selfPub, to: pub, ts: nowMs, ackSeq: st.lastSeenSeq })).catch(() => { });
      }
      updatePeerUI(pub);
    }

    function onBinaryFrame(fromPub, u8) {
      const f = VF2.parse(u8); if (!f) return;
      const pub = fromPub.toLowerCase();
      ensurePeer(pub, { ts: now(), vestigial: false, addr: bestAddrForPub(pub) || `web.${pub}` });
      let st = rxState.get(pub); if (!st) { st = { decoding: false, queued: null, lastAckSent: 0, lastSeenSeq: 0, rxFps: 0, rxTick: now(), rxCount: 0 }; rxState.set(pub, st); }
      st.queued = { fmtCode: f.fmtCode, u8: f.payload, w: f.w | 0, h: f.h | 0, ts: f.ts | 0, seq: f.seq | 0 };
      processQueue(pub);
    }

    /* ====== Peer tiles (grid) ====== */
    const grid = $('#grid');

    function ensurePeerTile(pub) {
      let tile = document.querySelector(`.peer[data-pub="${pub}"]`);
      if (tile) return tile;
      tile = document.createElement('div'); tile.className = 'peer'; tile.dataset.pub = pub;

      const frame = document.createElement('div'); frame.className = 'frame'; frame.title = 'Click to start/stop sending your stream';
      const overlayTop = document.createElement('div'); overlayTop.className = 'overlay top';
      const leftTop = document.createElement('div'); leftTop.style.display = 'flex'; leftTop.style.alignItems = 'center'; leftTop.style.gap = '6px';
      const dot = document.createElement('span'); dot.className = 'dot warn';
      const addr = document.createElement('span'); addr.className = 'addr mono'; addr.textContent = shortHex(pub, 8, 6);
      leftTop.appendChild(dot); leftTop.appendChild(addr);
      const rightTop = document.createElement('div'); rightTop.style.display = 'flex'; rightTop.style.gap = '6px'; rightTop.style.alignItems = 'center';
      const txBadge = document.createElement('span'); txBadge.className = 'chip tx'; txBadge.textContent = 'TX'; txBadge.hidden = true;
      rightTop.appendChild(txBadge);
      overlayTop.appendChild(leftTop); overlayTop.appendChild(rightTop);

      const preview = document.createElement('div'); preview.className = 'preview';

      const overlayBottom = document.createElement('div'); overlayBottom.className = 'overlay bottom';
      const meta = document.createElement('div'); meta.className = 'meta tiny'; meta.textContent = '—';
      overlayBottom.appendChild(meta);

      frame.appendChild(overlayTop);
      frame.appendChild(preview);
      frame.appendChild(overlayBottom);

      // beneath frame (secondary line with truncated address + dot again)
      const row = document.createElement('div'); row.className = 'row';
      const name = document.createElement('div'); name.className = 'name mono'; name.textContent = shortHex(pub, 8, 6);
      const dot2 = document.createElement('span'); dot2.className = 'dot warn';
      row.appendChild(name); row.appendChild(dot2);

      tile.appendChild(frame);
      tile.appendChild(row);
      grid.appendChild(tile);

      // click starts / stops streaming
      frame.addEventListener('click', async (e) => {
        e.stopPropagation(); await ensureCamStream();
        if (!streamsOut.has(pub)) { startStreamingTo(pub); txBadge.hidden = false; }
        else { stopStreamingTo(pub); txBadge.hidden = true; }
        updatePeerUI(pub);
      });

      return tile;
    }

    function peerMetaText(pub) { const ent = peers.get(pub) || {}; const ago = ent.lastTs ? fmtAgo(now() - ent.lastTs) + ' ago' : '—'; return ent.isVestigial ? `last seen ${ago}` : `active • ${ago}`; }
    function updatePeerUI(pub) {
      const tile = document.querySelector(`.peer[data-pub="${pub}"]`); if (!tile) return;
      const addrEl = tile.querySelector('.addr'); if (addrEl) addrEl.textContent = shortHex(pub, 8, 6);
      const nameEl = tile.querySelector('.name'); if (nameEl) nameEl.textContent = shortHex(pub, 8, 6);

      const st = streamsOut.get(pub) || null;
      const rx = rxState.get(pub) || null;
      const isOnlineNow = isPeerOnline(pub);

      // ⬇️ Only line changed: add 'blink' while TX is active
      const dotEls = tile.querySelectorAll('.dot');
      const baseClass = 'dot ' + (isOnlineNow ? 'ok' : (peers.get(pub)?.isVestigial ? 'err' : 'warn'));
      const blink = st ? ' blink' : ''; // blink when streaming to this peer
      dotEls.forEach(d => d.className = baseClass + blink);

      const txFps = st ? (st.txFps || 0) : 0;
      const rxFps = rx ? (rx.rxFps || 0) : 0;
      const avgKB = st?.sizeEMA != null ? Math.round(st.sizeEMA / 1024) : 0;
      const ackPct = st && st.ack ? (st.ack.winSent ? Math.round((st.ack.winAck / st.ack.winSent) * 100) : 0) : 0;

      const meta = tile.querySelector('.meta');
      if (meta) meta.textContent = `${peerMetaText(pub)} • tx ${txFps}fps • rx ${rxFps}fps • ~${avgKB}KB • ack ${ackPct}%`;

      const txBadge = tile.querySelector('.tx');
      if (txBadge) txBadge.hidden = !st;
    }

    setInterval(() => { for (const [pub] of peers.entries()) updatePeerUI(pub); }, 1200);

    /* ====== NKN wiring (binary aware) ====== */
    let SEND_GUARD = true; // simple guard to avoid send before connected
    async function connectNkn() {
      try {
        setNkn('NKN: connecting…', 'warn');
        const seed = getOrCreateSeed();
        client = new window.nkn.MultiClient({ seed, identifier: 'web', numSubClients: 8, originalClient: true });

        client.onConnect(() => {
          selfAddr = client.addr || null; selfPub = client.getPublicKey() || null;
          $('#myAddr') && ($('#myAddr').textContent = selfAddr || '—');
          setNkn('NKN: connected', 'ok'); scheduleHB(); scheduleTicks(); probeAll();
          for (const to of targets()) rawSend(to, JSON.stringify({ ver: 1, type: 'peers_req', id: `peers_req|${selfPub}|${now()}`, from: selfPub, ts: now() })).catch(() => { });
          ensureCamStream().catch(() => { });
          SEND_GUARD = false;
        });

        client.onMessage(async ({ src, payload }) => {
          if (src) {
            const m = /^([a-z0-9_-]+)\.([0-9a-f]{64})$/i.exec(src);
            if (m) { idSet(m[2].toLowerCase()).add(m[1]); persistKnownIds(); poolAdd(src, now()); ensurePeer(m[2].toLowerCase(), { addr: src, ts: now() }); }
            else { poolAdd(src, now()); }
          }

          // BINARY (VF2)
          if (payload instanceof Uint8Array && payload.length >= 3 && payload[0] === VF2.MAGIC0 && payload[1] === VF2.MAGIC1 && payload[2] === VF2.MAGIC2) {
            const pub = (src?.split('.')?.pop() || '').toLowerCase();
            if (pub) onBinaryFrame(pub, payload);
            return;
          }

          // JSON path
          let text = payload;
          if (payload instanceof Uint8Array) {
            try { text = new TextDecoder().decode(payload); } catch { return; }
          }
          if (typeof text !== 'string') return;
          let msg = null; if (text.trim().startsWith('{')) { try { msg = JSON.parse(text); } catch { } }
          const tsNow = now(); if (!msg) return; if (markSeen(msg)) return;

          if (msg.type === 'hb') { rawSend(src, JSON.stringify({ ver: 1, type: 'hb_ack', id: msg.id || `hb_ack|${selfPub}|${tsNow}`, from: selfPub, t_client: msg.t_client })).catch(() => { }); if (msg.from) ensurePeer(msg.from.toLowerCase(), { ts: tsNow }); return; }
          if (msg.type === 'hb_ack' && typeof msg.t_client === 'number') { const rtt = Math.max(0, tsNow - (msg.t_client || tsNow)); poolNoteAck(src, rtt); if (msg.from) { ensurePeer(msg.from.toLowerCase(), { ts: tsNow }); } return; }
          if (msg.type === 'tick') { if (msg.from) ensurePeer(msg.from.toLowerCase(), { ts: tsNow }); return; }

          if (msg.type === 'peers') { const arr = Array.isArray(msg.items) ? msg.items : []; for (const it of arr) { const pub = (it.pub || '').toLowerCase(); if (!pub || pub === (selfPub || '').toLowerCase()) continue; const ids = idSet(pub); (Array.isArray(it.ids) ? it.ids : []).forEach(id => ids.add(id)); ids.forEach(id => poolAdd(`${id}.${pub}`, tsNow)); const addrGuess = it.addr || (ids.size ? `${[...ids][0]}.${pub}` : `web.${pub}`); poolAdd(addrGuess, tsNow); ensurePeer(pub, { addr: addrGuess, ts: typeof it.last === 'number' ? it.last : tsNow, vestigial: !!it.vestigial }); } persistKnownIds(); return; }
          if (msg.type === 'peers_req') { const roster = { ver: 1, type: 'peers', id: `peers|${selfPub}|${now()}`, ts: now(), items: [...peers.entries()].map(([pub, ent]) => ({ pub, ids: [...idSet(pub)], addr: ent.addr || `web.${pub}`, last: ent.lastTs || 0, vestigial: !!ent.isVestigial })) }; rawSend(src, JSON.stringify(roster)).catch(() => { }); return; }

          if (msg.type === 'join') { const ack = { ver: 1, type: 'joined', id: `joined|${selfPub}|${tsNow}`, ts: tsNow, addr: selfAddr, prefix: 'peer' }; sendToBest(msg.from, JSON.stringify(ack)).catch(() => { }); const from = msg.from?.toLowerCase(); if (from) ensurePeer(from, { ts: tsNow }); return; }
          if (msg.type === 'joined') { poolNoteAck(src, null); return; }
          if (msg.type === 'leave' && msg.from) { const from = msg.from.toLowerCase(); const ent = peers.get(from) || {}; ensurePeer(from, { ts: tsNow, vestigial: true, addr: ent.addr || `web.${from}` }); return; }

          if (msg.type === 'video_offer' && msg.from && (!msg.to || msg.to === selfPub)) { const ack = { ver: 1, type: 'video_accept', id: `vack|${selfPub}|${tsNow}`, from: selfPub, to: msg.from, ts: tsNow }; sendToBest(msg.from, JSON.stringify(ack)).catch(() => { }); return; }
          if (msg.type === 'video_accept' && msg.from && msg.to === selfPub) { return; }

          // Legacy JSON frame path (compat)
          if (msg.type === 'video_frame' && msg.from && msg.b64 && (msg.fmt === 'jpeg' || msg.fmt === 'webp')) {
            const mime = (msg.fmt === 'webp') ? 'image/webp' : 'image/jpeg';
            const bin = atob(msg.b64); const u8 = new Uint8Array(bin.length); for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
            const pub = msg.from.toLowerCase();
            ensurePeer(pub, { ts: now(), vestigial: false, addr: bestAddrForPub(pub) || `web.${pub}` });
            let st = rxState.get(pub); if (!st) { st = { decoding: false, queued: null, lastAckSent: 0, lastSeenSeq: 0, rxFps: 0, rxTick: now(), rxCount: 0 }; rxState.set(pub, st); }
            st.queued = { fmtCode: (mime === 'image/jpeg') ? VF2.FMT_JPEG : VF2.FMT_WEBP, u8, w: msg.w | 0, h: msg.h | 0, ts: msg.ts | 0, seq: (msg.seq | 0) || 0 };
            processQueue(pub);
            return;
          }

          if (msg.type === 'video_ack' && msg.from && msg.to === selfPub) {
            const from = msg.from.toLowerCase();
            const st = streamsOut.get(from); if (!st) return;
            const ackSeq = (msg.ackSeq | 0) || 0;
            if (ackSeq > 0) {
              st.ack.winAck++; st.ack.lastAckAt = now();
              const e2e = now() - ackSeq;
              st.ack.e2eEma = st.ack.e2eEma == null ? e2e : 0.8 * st.ack.e2eEma + 0.2 * e2e;
              updatePeerUI(from);
            } else if (typeof msg.srcTs === 'number') { // legacy
              st.ack.winAck++; st.ack.lastAckAt = now(); const e2e = now() - msg.srcTs; st.ack.e2eEma = st.ack.e2eEma == null ? e2e : 0.8 * st.ack.e2eEma + 0.2 * e2e; updatePeerUI(from);
            }
            return;
          }
        });

        client.on('error', () => setNkn('NKN: error', 'err'));
        client.on('connectFailed', () => setNkn('NKN: connect failed (retrying)', 'warn'));
        client.on('willreconnect', () => setNkn('NKN: reconnecting…', 'warn'));
        client.on('close', () => setNkn('NKN: disconnected', 'err'));
      } catch { setNkn('NKN: init failed', 'err'); }
    }

    /* ====== dedupe for JSON msgs ====== */
    const seenIds = new Map(); setInterval(() => { const cut = now() - 120000; for (const [id, ts] of seenIds.entries()) if (ts < cut) seenIds.delete(id); }, 15000);
    function markSeen(msg) { const id = (msg && typeof msg.id === 'string') ? msg.id : `${msg?.type || '?'}|${msg?.from || '?'}|${msg?.ts || 0}`; const t = now(); const prev = seenIds.get(id); if (prev && (t - prev) < 60000) return true; seenIds.set(id, t); return false; }

    /* ====== signaller override + start ====== */
    function applySignallerHex(raw) {
      const v = (raw || '').trim().toLowerCase();
      signallerHex = isHex64(v) ? v : DEFAULT_SIG_HEX;
      if (isHex64(v)) localStorage.setItem(LS.SIGHEX, v);
      signallerPrefix = 'signal';
      const primary = `${signallerPrefix}.${signallerHex}`;
      poolAdd(primary, now()); setSig(`Mesh: prim ${shortHex(primary, 7, 6)} + peers`, 'warn'); setSigMeta('probing…');
      probeAll();
    }
    const hexInput = $('#hexSig'); if (hexInput) { hexInput.value = localStorage.getItem(LS.SIGHEX) || ''; hexInput.addEventListener('input', () => applySignallerHex(hexInput.value)); }
    applySignallerHex(hexInput?.value || DEFAULT_SIG_HEX);

    /* ====== join/leave pulses ====== */
    function periodicJoin() {
      if (!client || !client.addr || !selfPub) return;
      const pkt = { ver: 1, type: 'join', id: `join|${selfPub}|${now()}`, from: selfPub, addr: selfAddr, ts: now(), caps: { relay: true, roster: true } };
      for (const to of targets()) rawSend(to, JSON.stringify(pkt)).catch(() => { });
    }
    setInterval(periodicJoin, 15000);
    addEventListener('beforeunload', () => { try { const pkt = { ver: 1, type: 'leave', id: `leave|${selfPub}|${now()}`, from: selfPub, addr: selfAddr, ts: now() }; for (const to of targets()) rawSend(to, JSON.stringify(pkt)).catch(() => { }); } catch { } });

    /* ====== boot ====== */
    connectNkn();
    ensureCamStream().catch(() => { });
    scheduleHB(); scheduleTicks();

    /* ====== optional: self tile for visual consistency ====== */
    // You can comment this out if you don't want a self tile.
(function addSelfTile(){
  const pub = 'SELF_'+Math.random().toString(36).slice(2,7);
  const tile=document.createElement('div'); tile.className='peer self'; tile.dataset.pub=pub;

  const frame=document.createElement('div'); frame.className='frame';
  frame.style.cursor='pointer';
  frame.title='Tap to toggle front/back camera';
  frame.addEventListener('click', () => toggleFacing());

  const overlayTop=document.createElement('div'); overlayTop.className='overlay top';
  overlayTop.innerHTML = `<span class="chip"><span class="addr mono">${shortHex(selfPub||'you',6,6)}</span></span>`;

  const preview=document.createElement('div'); preview.className='preview';
  const video=document.querySelector('#localVideo');
  if(video){
    const ghost=document.createElement('video');
    ghost.muted=true; ghost.playsInline=true; ghost.autoplay=true;
    ghost.style.width='100%'; ghost.style.height='100%'; ghost.style.objectFit='cover';
    const setSrc=()=>{ if(video.srcObject){ ghost.srcObject=video.srcObject; ghost.play().catch(()=>{}); } else setTimeout(setSrc,400); };
    setSrc();
    preview.appendChild(ghost);
  }

  const overlayBottom=document.createElement('div'); overlayBottom.className='overlay bottom';
  overlayBottom.innerHTML = `<div class="meta tiny">local preview — click to flip camera</div>`;

  frame.appendChild(overlayTop); frame.appendChild(preview); frame.appendChild(overlayBottom);
  const row=document.createElement('div'); row.className='row'; row.innerHTML=`<div class="name mono">you</div>`;
  tile.appendChild(frame); tile.appendChild(row);
  grid.prepend(tile);
})();

  </script>
</body>

</html>
