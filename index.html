<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>NKN Mesh — Multi-Peer Video (Mobile-First, Click-to-Stream)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://unpkg.com/nkn-sdk@1.3.6/dist/nkn.min.js"></script>
    <style>
        :root {
            --bg: #0b0b0b;
            --fg: #eee;
            --muted: #9aa0a6;
            --line: #1b1b1b;
            --ok: #30cf6b;
            --warn: #f7b500;
            --err: #e84d4d;
            --card: #0f1011;
            --chip: #0a0a0a;
            --accent: #3b82f6;
            --frame: #000;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px/1.5 system-ui, -apple-system, Segoe UI, Roboto, sans-serif
        }

        /* Header */
        .bar {
            position: sticky;
            top: 0;
            width: 100vw;
            z-index: 30;
            display: flex;
            flex-flow: row;
            overflow-x: auto;
            align-items: center;
            gap: 10px;
            box-sizing: border-box;
            padding: 10px 12px;
            background: rgba(10, 10, 10, .9);
            backdrop-filter: saturate(1.2) blur(6px);
            border-bottom: 1px solid var(--line);
        }

        .bar h1 {
            margin: 0;
            font-size: 16px
        }

        .grow {
            flex: 1
        }

        .mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace
        }

        .tiny {
            font-size: 12px;
            color: var(--muted)
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #444;
            border: 1px solid #222;
            display: inline-block
        }

        .ok {
            background: var(--ok)
        }

        .warn {
            background: var(--warn)
        }

        .err {
            background: var(--err)
        }

        @keyframes nknTxBlink {

            0%,
            55% {
                opacity: 1
            }

            55%,
            100% {
                opacity: .35
            }
        }

        .dot.ok.blink {
            animation: nknTxBlink 1s linear infinite;
        }

        .kv {
            display: inline-flex;
            gap: 6px;
            align-items: center;
            background: #0a0a0a;
            border: 1px solid #222;
            border-radius: 8px;
            padding: 3px 8px
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #252525;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 12px;
            background: #0a0a0a
        }

        /* Sidebar */
        .sideToggle {
            appearance: none;
            border: 1px solid #333;
            background: #111;
            color: #fff;
            border-radius: 10px;
            padding: 8px 10px;
            cursor: pointer;
            z-index: 2;
        }

        .sidebar {
            position: absolute;
            inset: 0 auto 0 0;
            width: min(90vw, 360px);
            transform: translateX(-100%);
            transition: transform .25s ease;
            background: var(--card);
            border-right: 1px solid #1b1b1b;
            z-index: 50;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 12px;
            overflow-x: clip;
            overflow-y: auto;
            padding: 12px;
            top: 54px;
            max-height: calc(100vh - 54px);
        }

        .backToggle {
            display: flex;
            height: 100vh;
            width: 100vw;
            position: fixed;
            z-index: 1;
            backdrop-filter: blur(20px);
            transform: translateX(-100%);
        }

        .backToggle.open {
            transform: none;
        }

        .sidebar.open {
            transform: none
        }

        .sideSection {
            border: 1px solid #1d1d1d;
            border-radius: 12px;
            padding: 10px;
            background: #101113
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin: 8px 0 6px
        }

        input[type="text"],
        select {
            width: 100%;
            height: 36px;
            background: #000;
            border: 1px solid #242424;
            border-radius: 10px;
            color: var(--fg);
            padding: 8px 10px
        }

        input[type="range"] {
            width: 100%
        }

        /* Content */
        .wrap {
            max-width: 1800px;
            margin: 0 auto;
            padding: 10px
        }

        .wrap-bar {
            display: flex;
            flex-flow: row;
            gap: 10px;
        }

        #grid {
            display: grid;
            gap: 10px;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
        }

        /* Peer tile */
        .peer {
            border: 1px solid #1b1b1b;
            border-radius: 12px;
            overflow: hidden;
            background: #0b0c0d;
        }

        .frame {
            position: relative;
            background: var(--frame);
            border-bottom: 1px solid #161616;
            aspect-ratio: 4/3;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            cursor: pointer;
        }

        .frame:active {
            transform: translateY(1px)
        }

        .preview {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000
        }

        .preview canvas {
            display: block;
            width: 100%;
            height: 100%;
            object-fit: cover
        }

        .overlay {
            position: absolute;
            left: 8px;
            right: 8px;
            display: flex;
            align-items: center;
            pointer-events: none;
            gap: 6px;
            font-size: 12px;
        }

        .overlay.top {
            top: 8px;
            justify-content: space-between
        }

        .overlay.bottom {
            bottom: 8px;
            justify-content: flex-start;
            color: #ddd
        }

        .chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 2px 8px;
            border-radius: 999px;
            border: 1px solid #222;
            background: #0a0a0a
        }

        .tx {
            font-weight: 600;
            border-color: #2a2a2a
        }

        .addr {
            font-weight: 600
        }

        .meta {
            font-size: 11px;
            color: var(--muted);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis
        }

        .row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px
        }

        .row.head {
            justify-content: space-between
        }

        .name {
            font-weight: 600
        }

        .muted {
            color: var(--muted)
        }

        /* Self tile (optional) */
        .self .overlay.top .addr::after {
            content: " (you)";
            font-weight: 400;
            color: var(--muted);
        }

        /* Status chips in header */
        .status {
            display: flex;
            flex-flow: row;
            overflow-x: auto;
            gap: 8px;
            align-items: center;
            width: max-content;
        }

        .hideme {
            display: none
        }

        @media (min-width: 920px) {
            #grid {
                grid-template-columns: repeat(auto-fill, minmax(550px, 1fr));
                gap: 12px
            }
        }
    </style>
</head>

<body>
    <!-- Header -->
    <div class="bar">
        <div class="wrap-bar">
            <button id="btnSide" class="sideToggle">☰</button>
            <div class="grow"></div>
            <div class="status tiny">
                <span class="kv"><span id="txtNkn">NKN: connecting…</span><span id="dotNkn" class="dot"></span></span>
                <span class="kv"><span id="txtSig">Mesh: discovering…</span><span id="dotSig" class="dot"></span></span>
                <span id="txtSigMeta" class="tiny">—</span>
            </div>
        </div>
    </div>

    <!-- Sidebar (hidden controls) -->
    <aside id="sidebar" class="sidebar">
        <div class="sideSection">
            <div class="row head">
                <div class="badge">Local Video</div>
                <div class="tiny">Your addr: <span id="myAddr" class="mono">—</span></div>
            </div>
            <video id="localVideo" muted playsinline autoplay
                style="width:100%;border:1px solid #222;border-radius:10px;background:#000;max-height:180px;object-fit:cover"></video>
            <div class="row" style="flex-wrap:wrap">
                <span class="kv"><span>Src FPS</span><strong id="mFps">—</strong></span>
                <span class="kv"><span>Avg KB</span><strong id="mSize">—</strong></span>
                <span class="kv"><span>Sent</span><strong id="mSent">0</strong></span>
                <span class="kv"><span>Dropped</span><strong id="mDrop">0</strong></span>
            </div>
        </div>

        <div class="sideSection">
            <label>Primary Signaller Public Key (64-hex) — override</label>
            <input id="hexSig" class="mono" placeholder="64-hex (blank = default)" spellcheck="false" />
            <div class="tiny">Default: <code
                    class="mono">5a0a81a8e4d6538a81e59d04057611a779f762da49c5eaf79a96badb91788c0c</code></div>
        </div>

        <div class="sideSection">
            <div class="badge">Encoder & Delivery</div>
            <label>Target FPS</label>
            <input id="fpsSlider" type="range" min="4" max="30" step="1" value="25" />
            <div class="tiny"><span id="fpsLbl">25</span> fps (global cadence)</div>

            <label>Scale (downsize)</label>
            <input id="sSlider" type="range" min="0.4" max="1.0" step="0.05" value="0.5" />
            <div class="tiny">Lower = fewer pixels</div>

            <label>Quality</label>
            <select id="fmtQ">
                <option value="jpeg:0.60" selected>JPEG 0.60</option>
                <option value="jpeg:0.70">JPEG 0.70</option>
                <option value="webp:0.60">WebP 0.60</option>
                <option value="webp:0.70">WebP 0.70</option>
            </select>

            <label>Max KB / frame</label>
            <input id="kbSlider" type="range" min="80" max="900" step="20" value="380" />
            <div class="tiny"><span id="kbLbl">380</span> KB cap</div>

            <label>Realtime Bias (latency ⇄ quality)</label>
            <input id="biasSlider" type="range" min="0" max="1" step="0.05" value="0.7" />
            <div class="tiny">Higher = prefer lower delay, pace per-peer when E2E rises</div>
        </div>
        <div class="sideSection" id="audioControls">
            <div class="badge">Audio (PCM / μ-law / Opus)</div>

            <label>Sample rate</label>
            <select id="aRate">
                <option value="8000">8 kHz (tiny)</option>
                <option value="12000">12 kHz</option>
                <option value="16000" selected>16 kHz (clear)</option>
            </select>

            <label>Frame size</label>
            <select id="aMs">
                <option value="20">20 ms</option>
                <option value="40" selected>40 ms</option>
                <option value="60">60 ms</option>
                <option value="80">80 ms</option>
            </select>

            <label>Format</label>
            <select id="aFmt">
                <option value="mulaw8" selected>μ-law 8-bit</option>
                <option value="pcm16le">PCM 16-bit</option>
                <option value="opus">Opus (webm)</option>
            </select>

            <div class="tiny" id="aEstimate" style="margin-top:6px">—</div>
            <div class="row" style="gap:10px;margin-top:6px">
                <span class="kv"><span>Src FPS</span><strong id="aFps">—</strong></span>
                <span class="kv"><span>Avg KB</span><strong id="aSize">—</strong></span>
                <span class="kv"><span>Sent</span><strong id="aSent">0</strong></span>
                <span class="kv"><span>Dropped</span><strong id="aDrop">0</strong></span>
            </div>
        </div>

    </aside>

    </button>

    <!-- Grid -->
    <div class="wrap">
        <div id="grid"></div>
    </div>

    <script>
        /* ====== helpers ====== */
        const $ = s => document.querySelector(s);
        const shortHex = (s, a = 8, b = 6) => s ? (s.slice(0, a) + '…' + s.slice(-b)) : '—';
        const isHex64 = s => /^[0-9a-f]{64}$/i.test((s || '').trim());
        const now = () => Date.now();
        const fmtAgo = ms => { if (ms < 1500) return 'now'; const s = Math.floor(ms / 1000); if (s < 60) return s + 's'; const m = Math.floor(s / 60); if (m < 60) return m + 'm'; const h = Math.floor(m / 60); if (h < 24) return h + 'h'; const d = Math.floor(h / 24); return d + 'd'; };
        const setNkn = (t, cls) => { $('#txtNkn').textContent = t; $('#dotNkn').className = 'dot ' + (cls || ''); };
        const setSig = (t, cls) => { $('#txtSig').textContent = t; $('#dotSig').className = 'dot ' + (cls || ''); };
        const setSigMeta = t => { $('#txtSigMeta').textContent = t; };

        const LS = { SEED: 'NKN_SEED_HEX_V1', SIGHEX: 'NKN_SIG_HEX', KNOWN_IDS: 'NKN_KNOWN_IDS_V2' };
        const DEFAULT_SIG_HEX = '5a0a81a8e4d6538a81e59d04057611a779f762da49c5eaf79a96badb91788c0c';
        const toHex = u8 => Array.from(u8).map(b => b.toString(16).padStart(2, '0')).join('');
        function getOrCreateSeed() { let hex = localStorage.getItem(LS.SEED); if (/^[0-9a-f]{64}$/i.test(hex || '')) return hex; const u = new Uint8Array(32); crypto.getRandomValues(u); hex = toHex(u); localStorage.setItem(LS.SEED, hex); return hex; }

        /* ====== layout / sidebar ====== */
        const sidebar = $('#sidebar');
        const btnback = $('#btnBack');
        $('#btnSide').addEventListener('click', () => sidebar.classList.toggle('open'));
        $('#btnSide').addEventListener('click', () => btnback.classList.toggle('open'));

        /* ====== mesh / peer state ====== */
        let client = null, selfPub = null, selfAddr = null;
        let signallerHex = '', signallerPrefix = 'signal';

        const peers = new Map(); // pub -> {addr,lastTs,isVestigial}
        const knownIdsByPub = new Map(); const idSet = (pub) => { let s = knownIdsByPub.get(pub); if (!s) { s = new Set(['peer', 'web', 'signal']); knownIdsByPub.set(pub, s); } return s; };
        (function loadKnownIds() { try { const t = localStorage.getItem(LS.KNOWN_IDS); if (!t) return; const j = JSON.parse(t); for (const [k, arr] of Object.entries(j)) knownIdsByPub.set(k, new Set(arr)); } catch { } })();
        const persistKnownIds = () => { const obj = {}; for (const [k, set] of knownIdsByPub.entries()) obj[k] = [...set]; localStorage.setItem(LS.KNOWN_IDS, JSON.stringify(obj)); };

        const addrPool = new Map(); // addr -> {lastSeen,lastAck,rttMs,updates,failures,lastProbe}
        const lastLive = (m) => Math.max(m?.lastAck || 0, m?.lastSeen || 0);
        function poolAdd(addr, when = now()) { if (!addr) return; const m = addrPool.get(addr) || { lastSeen: 0, lastAck: 0, rttMs: null, updates: 0, failures: 0, lastProbe: 0 }; m.lastSeen = Math.max(m.lastSeen, when); addrPool.set(addr, m); updateSigMeta(); }
        function poolNoteAck(addr, rtt = null) { const m = addrPool.get(addr) || { lastSeen: 0, lastAck: 0, rttMs: null, updates: 0, failures: 0, lastProbe: 0 }; m.lastAck = now(); if (rtt != null) m.rttMs = rtt; addrPool.set(addr, m); updateSigMeta(); }
        function poolNoteUpdate(addr) { const m = addrPool.get(addr) || { lastSeen: 0, lastAck: 0, rttMs: null, updates: 0, failures: 0, lastProbe: 0 }; m.lastSeen = now(); m.updates += 1; addrPool.set(addr, m); updateSigMeta(); }
        function isPeerOnline(pub) { return addressesForPub(pub).some(a => (now() - (addrPool.get(a)?.lastAck || addrPool.get(a)?.lastSeen || 0)) < 45000); }
        function onlineCount() { let n = 0; for (const [addr, m] of addrPool.entries()) if ((now() - (m.lastAck || m.lastSeen || 0)) < 15000) n++; return n; }
        function updateSigMeta() {
            let best = null, bRtt = Infinity, bSeen = 0;
            for (const [addr, m] of addrPool.entries()) {
                const r = m.rttMs == null ? Infinity : m.rttMs; const s = Math.max(m.lastAck || 0, m.lastSeen || 0);
                if (r < bRtt || (r === bRtt && s > bSeen)) { best = addr; bRtt = r; bSeen = s; }
            }
            const live = onlineCount(), total = addrPool.size;
            if (!best) { setSig('Mesh: discovering…', 'warn'); setSigMeta(`targets: ${total} • online: ${live} • latency: —`); }
            else { const lastSeenStr = bSeen ? `${fmtAgo(now() - bSeen)} ago` : '—'; const rtt = (bRtt === Infinity) ? '—' : `${Math.round(bRtt)} ms`; setSig(`Mesh: ${shortHex(best, 7, 6)} • ${live}/${total} online`, 'ok'); setSigMeta(`last seen: ${lastSeenStr} • latency: ${rtt}`); }
        }

        function ensurePeer(pub, { addr = null, ts = now(), vestigial = false } = {}) { const p = (peers.get(pub) || { addr: null, lastTs: 0, isVestigial: false }); if (addr) p.addr = addr; if (ts > (p.lastTs || 0)) p.lastTs = ts; p.isVestigial = !!vestigial; peers.set(pub, p); ensurePeerTile(pub); updatePeerUI(pub); }

        function addressesForPub(pub) { const ids = idSet(pub); const set = new Set(); const ent = peers.get(pub); if (ent?.addr) set.add(ent.addr); ids.forEach(id => set.add(`${id}.${pub}`)); return [...set]; }
        function bestAddrForPub(pub) {
            const list = addressesForPub(pub);
            let best = null, bRtt = Infinity, bSeen = 0;
            for (const a of list) { const m = addrPool.get(a) || {}; const r = (m.rttMs == null) ? Infinity : m.rttMs; const s = Math.max(m.lastAck || 0, m.lastSeen || 0); if (r < bRtt || (r === bRtt && s > bSeen)) { best = a; bRtt = r; bSeen = s; } }
            return best || list[0];
        }
        // ───────────────────────────────── Audio capability detection
        const opusSupported = (() => {
            const mime = 'audio/webm; codecs=opus';
            const mr = (window.MediaRecorder && window.MediaRecorder.isTypeSupported && window.MediaRecorder.isTypeSupported(mime));
            const mse = (window.MediaSource && window.MediaSource.isTypeSupported && window.MediaSource.isTypeSupported(mime));
            return !!(mr && mse);
        })();
        (() => {
            const fmtSel = document.querySelector('#aFmt');
            if (fmtSel && !opusSupported) {
                const opt = [...fmtSel.options].find(o => o.value === 'opus');
                if (opt) opt.disabled = true;
            }
        })();

        /* ====== HB / roster ====== */
        let hbTimer = null, tickTimer = null;
        function targets(max = 200) {
            const set = new Set();
            if (isHex64(signallerHex)) set.add(`${signallerPrefix}.${signallerHex}`);
            for (const a of addrPool.keys()) set.add(a);
            for (const [pub, ent] of peers.entries()) {
                if (ent.addr) set.add(ent.addr);
                idSet(pub).forEach(id => set.add(`${id}.${pub}`));
            }
            const out = []; for (const a of set.values()) { if (a !== selfAddr) out.push(a); if (out.length >= max) break; } return out;
        }
        function probeAll() {
            if (!client || !client.addr || !selfPub) return;
            const list = targets(); const t0 = now();
            for (const to of list) {
                const id = `hb|${selfPub}|${t0}|${to}`;
                const m = addrPool.get(to) || {}; m.lastProbe = t0; addrPool.set(to, m);
                rawSend(to, JSON.stringify({ ver: 1, type: 'hb', id, from: selfPub, t_client: t0, caps: { relay: true, roster: true } })).catch(() => { });
                rawSend(to, JSON.stringify({ ver: 1, type: 'peers_req', id: `peers_req|${selfPub}|${t0}`, from: selfPub, ts: t0 })).catch(() => { });
            }
        }
        function scheduleHB() { if (hbTimer) clearInterval(hbTimer); hbTimer = setInterval(probeAll, 12000); }
        function scheduleTicks() {
            if (tickTimer) clearInterval(tickTimer); tickTimer = setInterval(() => {
                const t = now(); for (const [addr, m] of addrPool.entries()) { if ((t - Math.max(m.lastSeen || 0, m.lastAck || 0)) < 60000) { rawSend(addr, JSON.stringify({ ver: 1, type: 'tick', id: `tick|${selfPub}|${t}|${addr}`, from: selfPub, ts: t })).catch(() => { }); } }
            }, 5000);
        }

        /* ====== NKN send helpers ====== */
        let SEND_OPTS = { noReply: true, maxHoldingSeconds: 0 }; // drop vs queue → lower latency
        async function rawSend(to, payload) { try { return await client.send(to, payload, SEND_OPTS); } catch (e) { throw e; } }
        async function sendToBest(pub, payload) {
            const list = addressesForPub(pub).sort((a, b) => {
                const ma = addrPool.get(a) || {}, mb = addrPool.get(b) || {};
                const ra = ma.rttMs == null ? 1e12 : ma.rttMs, rb = mb.rttMs == null ? 1e12 : mb.rttMs;
                if (ra !== rb) return ra - rb;
                return (Math.max(mb.lastAck || 0, mb.lastSeen || 0)) - (Math.max(ma.lastAck || 0, ma.lastSeen || 0));
            });
            for (const to of list) { try { await rawSend(to, payload); return true; } catch { } }
            if (isHex64(signallerHex)) { try { await rawSend(`${signallerPrefix}.${signallerHex}`, payload); return true; } catch { } }
            return false;
        }

        /* ====== local camera + VF2 encoder ====== */
        const localVideo = $('#localVideo'), fpsSlider = $('#fpsSlider'), sSlider = $('#sSlider'), fmtQ = $('#fmtQ'), kbSlider = $('#kbSlider'), biasSlider = $('#biasSlider');
        const fpsLbl = $('#fpsLbl'), kbLbl = $('#kbLbl');
        fpsSlider?.addEventListener('input', () => fpsLbl.textContent = fpsSlider.value);
        kbSlider?.addEventListener('input', () => kbLbl.textContent = kbSlider.value);

        const mFps = $('#mFps'), mSize = $('#mSize'), mSent = $('#mSent'), mDrop = $('#mDrop');
        let srcFpsCount = 0, totalSent = 0, totalDropped = 0, sizeEMA = null;
        setInterval(() => { if (mFps) mFps.textContent = String(srcFpsCount); srcFpsCount = 0; if (mSize) mSize.textContent = sizeEMA ? Math.round(sizeEMA / 1024) + ' KB' : '—'; if (mSent) mSent.textContent = String(totalSent); if (mDrop) mDrop.textContent = String(totalDropped); }, 1000);

        // --- Camera facing toggle (front/back) ---------------------------------------
        let CAM_FACING = localStorage.getItem('NKN_CAM_FACING') || 'user';

        async function restartLocalCamera() {
            // stop old tracks (if any)
            try {
                const old = localVideo?.srcObject;
                if (old) [...old.getVideoTracks(), ...old.getAudioTracks()].forEach(t => t.stop());
            } catch { }

            // try exact, then ideal, then fallback without facingMode
            const base = { width: { ideal: 640 }, height: { ideal: 480 }, frameRate: { ideal: 30, max: 30 } };
            const tries = [
                { video: { ...base, facingMode: { exact: CAM_FACING } }, audio: false },
                { video: { ...base, facingMode: CAM_FACING }, audio: false },
                { video: { ...base }, audio: false }
            ];

            let stream = null, lastErr = null;
            for (const c of tries) {
                try { stream = await navigator.mediaDevices.getUserMedia(c); break; }
                catch (e) { lastErr = e; }
            }
            if (!stream) throw lastErr || new Error('getUserMedia failed');

            if (localVideo) {
                localVideo.srcObject = stream;
                try { await localVideo.play(); } catch { }
            }

            // keep self-tile preview in sync
            const ghost = document.querySelector('.peer.self .preview video');
            if (ghost) {
                ghost.srcObject = stream;
                try { await ghost.play(); } catch { }
            }
        }

        async function toggleFacing() {
            CAM_FACING = (CAM_FACING === 'user') ? 'environment' : 'user';
            localStorage.setItem('NKN_CAM_FACING', CAM_FACING);
            await restartLocalCamera();  // encoder keeps running; canvas picks up new frames
        }


        // ── Screen share as camera source ─────────────────────────────────────────────
        let SCREEN_ACTIVE = false;
        let screenStream = null, screenVideo = null;
        let ssCanvas = null, ssCtx = null, ssRAF = null, lastSSEncAt = 0;
        let latestVF2_SS = null; // parallel to latestVF2 (camera)

        function setLocalPreviewStream(stream) {
            // point encoder source
            if (localVideo) {
                localVideo.srcObject = stream;
                try { localVideo.play(); } catch { }
            }
            // keep self-tile ghost in sync (if present)
            const ghost = document.querySelector('.peer.self .preview video');
            if (ghost) {
                ghost.srcObject = stream;
                try { ghost.play(); } catch { }
            }
        }

        function setSelfTilePreview(stream) {
            const ghost = document.querySelector('.peer.self .preview video');
            if (!ghost) return;
            try { ghost.srcObject = stream; ghost.play().catch(() => { }); } catch { }
        }

        async function startScreenShare() {
            if (screenStream) return true;
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: { frameRate: { ideal: 30, max: 30 } },
                    audio: false
                });
            } catch (e) { console.warn('getDisplayMedia failed', e); return false; }

            screenVideo = document.createElement('video');
            screenVideo.muted = true; screenVideo.playsInline = true; screenVideo.autoplay = true;
            screenVideo.style.display = 'none';
            document.body.appendChild(screenVideo);
            screenVideo.srcObject = screenStream;
            try { await screenVideo.play(); } catch { }

            // If user stops from browser UI, clean up + restore camera preview
            const vt = screenStream.getVideoTracks()[0];
            vt && vt.addEventListener('ended', () => stopScreenShare());

            // ✅ Show screen in the self tile (without touching #localVideo / camera encoder)
            SCREEN_ACTIVE = true;
            setSelfTilePreview(screenStream);

            startScreenEncoder();
            return true;
        }

        function stopScreenShare() {
            try { screenStream?.getTracks().forEach(t => t.stop()); } catch { }
            screenStream = null; latestVF2_SS = null;

            if (screenVideo) { try { screenVideo.remove(); } catch { } screenVideo = null; }
            if (ssRAF) { cancelAnimationFrame(ssRAF); ssRAF = null; }

            // ✅ Restore the self tile preview back to camera
            SCREEN_ACTIVE = false;
            setSelfTilePreview(localVideo?.srcObject || null);
        }

        function stopScreenShare() {
            try { screenStream?.getTracks().forEach(t => t.stop()); } catch { }
            screenStream = null; latestVF2_SS = null;

            if (screenVideo) { try { screenVideo.remove(); } catch { } screenVideo = null; }
            if (ssRAF) { cancelAnimationFrame(ssRAF); ssRAF = null; }
        }

        function maybeStopScreenWhenUnused() {
            for (const [, st] of streamsOut) { if (st?.preferredSrc === 'screen') return; }
            stopScreenShare();
        }

        function startScreenEncoder() {
            if (ssRAF) return;
            ssCanvas = document.createElement('canvas');
            ssCtx = ssCanvas.getContext('2d', { alpha: false, desynchronized: true });

            const encodeOnce = async () => {
                if (!screenVideo || screenVideo.videoWidth <= 0) return null;
                const scale = parseFloat(sSlider?.value || '0.7');
                const w = Math.max(2, Math.round(screenVideo.videoWidth * scale));
                const h = Math.max(2, Math.round(screenVideo.videoHeight * scale));
                if (ssCanvas.width !== w || ssCanvas.height !== h) { ssCanvas.width = w; ssCanvas.height = h; }
                ssCtx.drawImage(screenVideo, 0, 0, w, h);

                const [fmt, qStr] = (fmtQ?.value || 'jpeg:0.6').split(':'); const q = parseFloat(qStr || '0.6');
                const mime = (fmt === 'webp') ? 'image/webp' : 'image/jpeg';
                let blob = await new Promise(res => ssCanvas.toBlob(res, mime, q));
                const targetKB = parseInt(kbSlider?.value || '380', 10);
                if (blob && blob.size > targetKB * 1024 && q > 0.4) {
                    blob = await new Promise(res => ssCanvas.toBlob(res, mime, Math.max(0.4, q - 0.1)));
                }
                if (!blob) return null;
                const u8 = new Uint8Array(await blob.arrayBuffer());
                const ts = now(), seq = ts | 0;
                const fmtCode = (mime === 'image/jpeg') ? VF2.FMT_JPEG : VF2.FMT_WEBP;
                return {
                    ts, seq, w, h, bytes: u8.byteLength,
                    packed: VF2.pack({ fmtCode, w, h, ts, seq, bytesU8: u8 })
                };
            };

            const step = async (t) => {
                const targetMs = 1000 / parseInt(fpsSlider?.value || '18', 10);
                if ((t - lastSSEncAt) >= targetMs) {
                    lastSSEncAt = t;
                    const vf2 = await encodeOnce();
                    if (vf2) {
                        latestVF2_SS = vf2;
                        // nudge only peers that requested screen
                        for (const [pub, st] of streamsOut) {
                            if (st?.preferredSrc === 'screen') sendLatestToPeer(pub);
                        }
                    }
                }
                ssRAF = requestAnimationFrame(step);
            };
            ssRAF = requestAnimationFrame(step);
        }



        async function ensureCamStream() {
            if (localVideo?.srcObject) return localVideo.srcObject;
            await restartLocalCamera();        // respects CAM_FACING from step 1
            startGlobalEncoder();              // kick encoder once
            return localVideo.srcObject;
        }

        let encCanvas = null, encCtx = null, encRAF = null, lastEncAt = 0, latestVF2 = null;
        // VF2 header: 18 bytes (MAGIC + meta) + payload
        const VF2 = {
            MAGIC0: 0x56, MAGIC1: 0x46, MAGIC2: 0x32, VER: 1,
            FMT_JPEG: 1, FMT_WEBP: 2,
            pack({ fmtCode, w, h, ts, seq, bytesU8 }) {
                const out = new Uint8Array(18 + bytesU8.byteLength);
                out[0] = this.MAGIC0; out[1] = this.MAGIC1; out[2] = this.MAGIC2; out[3] = this.VER;
                out[4] = fmtCode; out[5] = 0; // flags
                const dv = new DataView(out.buffer, out.byteOffset, out.byteLength);
                dv.setUint16(6, w, false); dv.setUint16(8, h, false);
                dv.setUint32(10, ts >>> 0, false);
                dv.setUint32(14, seq >>> 0, false);
                out.set(bytesU8, 18);
                return out;
            },
            parse(u8) {
                if (!u8 || u8.length < 18) return null;
                if (u8[0] !== this.MAGIC0 || u8[1] !== this.MAGIC1 || u8[2] !== this.MAGIC2) return null;
                const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
                const ver = u8[3]; if (ver !== this.VER) return null;
                const fmtCode = u8[4];
                const w = dv.getUint16(6, false), h = dv.getUint16(8, false);
                const ts = dv.getUint32(10, false), seq = dv.getUint32(14, false);
                const payload = u8.subarray(18);
                return { fmtCode, w, h, ts, seq, payload };
            },
            mimeFromCode(c) { return c === 1 ? 'image/jpeg' : (c === 2 ? 'image/webp' : 'application/octet-stream'); }
        };

        function startGlobalEncoder() {
            if (encRAF) return;
            encCanvas = document.createElement('canvas');
            encCtx = encCanvas.getContext('2d', { alpha: false, desynchronized: true });

            const encodeOnce = async () => {
                if (!localVideo || localVideo.videoWidth <= 0) return null;
                const scale = parseFloat(sSlider?.value || '0.7');
                const w = Math.max(2, Math.round(localVideo.videoWidth * scale));
                const h = Math.max(2, Math.round(localVideo.videoHeight * scale));
                if (encCanvas.width !== w || encCanvas.height !== h) { encCanvas.width = w; encCanvas.height = h; }
                encCtx.drawImage(localVideo, 0, 0, w, h);

                const [fmt, qStr] = (fmtQ?.value || 'jpeg:0.6').split(':'); const q = parseFloat(qStr || '0.6');
                const mime = (fmt === 'webp') ? 'image/webp' : 'image/jpeg';
                let blob = await new Promise(res => encCanvas.toBlob(res, mime, q));
                const targetKB = parseInt(kbSlider?.value || '380', 10);
                if (blob && blob.size > targetKB * 1024 && q > 0.4) {
                    blob = await new Promise(res => encCanvas.toBlob(res, mime, Math.max(0.4, q - 0.1)));
                }
                if (!blob) return null;
                const u8 = new Uint8Array(await blob.arrayBuffer());
                sizeEMA = sizeEMA == null ? u8.byteLength : (0.8 * sizeEMA + 0.2 * u8.byteLength);
                const ts = now(), seq = ts | 0;
                const fmtCode = (mime === 'image/jpeg') ? VF2.FMT_JPEG : VF2.FMT_WEBP;
                const packed = VF2.pack({ fmtCode, w, h, ts, seq, bytesU8: u8 });
                srcFpsCount++;
                return { ts, seq, w, h, bytes: u8.byteLength, packed };
            };

            // Align to real camera frame cadence when available
            const useRVFC = 'requestVideoFrameCallback' in HTMLVideoElement.prototype;
            const stepRAF = async (t) => {
                const targetMs = 1000 / parseInt(fpsSlider?.value || '18', 10);
                if ((t - lastEncAt) >= targetMs) {
                    lastEncAt = t;
                    const vf2 = await encodeOnce();
                    if (vf2) { latestVF2 = vf2; for (const [pub] of streamsOut) sendLatestToPeer(pub); }
                }
                encRAF = requestAnimationFrame(stepRAF);
            };
            const stepRVFC = async () => {
                if (!localVideo?.requestVideoFrameCallback) { stepRAF(0); return; }
                localVideo.requestVideoFrameCallback(async () => {
                    const targetMs = 1000 / parseInt(fpsSlider?.value || '18', 10);
                    const t = performance.now();
                    if ((t - lastEncAt) >= targetMs) {
                        lastEncAt = t;
                        const vf2 = await encodeOnce();
                        if (vf2) { latestVF2 = vf2; for (const [pub] of streamsOut) sendLatestToPeer(pub); }
                    }
                    stepRVFC();
                });
            };

            if (useRVFC) stepRVFC(); else encRAF = requestAnimationFrame(stepRAF);
        }

        // ───────────────────────────────── Audio controls refs & metrics
        const aRate = $('#aRate'), aMs = $('#aMs'), aFmt = $('#aFmt'), aEstimate = $('#aEstimate');
        const aFps = $('#aFps'), aSize = $('#aSize'), aSent = $('#aSent'), aDrop = $('#aDrop');

        let audioCtx = null, micStream = null, micSource = null, procNode = null;
        let latestAudio = null, latestOpus = null; // current frame objects
        let a_srcFps = 0, a_sizeEMA = null, a_totalSent = 0, a_totalDrop = 0;

        function ensureAudioCtx() { if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } }
        function updateAudioEstimate() {
            if (!aRate || !aMs || !aFmt || !aEstimate) return;
            const fmt = aFmt.value;
            if (fmt === 'opus') { aEstimate.textContent = 'Opus (WebM) • variable bitrate • timeslice = frame size'; return; }
            const sr = parseInt(aRate.value, 10), ms = parseInt(aMs.value, 10);
            const samples = Math.round(sr * ms / 1000);
            const bytes = (fmt === 'mulaw8') ? samples * 1 : samples * 2;
            const kb = Math.round(bytes / 1024);
            aEstimate.textContent = `~${samples} samples / frame • ~${kb} KB per frame (base64 +33%)`;
        }
        [aRate, aMs, aFmt].forEach(el => el && el.addEventListener('change', () => { stopPcmPipeline(); stopOpusPipeline(); latestAudio = null; latestOpus = null; a_sizeEMA = null; a_srcFps = 0; updateAudioEstimate(); }));
        updateAudioEstimate();
        setInterval(() => { if (aFps) aFps.textContent = String(a_srcFps); a_srcFps = 0; if (aSize) aSize.textContent = a_sizeEMA ? Math.round(a_sizeEMA / 1024) + ' KB' : '—'; if (aSent) aSent.textContent = String(a_totalSent); if (aDrop) aDrop.textContent = String(a_totalDrop); }, 1000);

        // ── μ-law helpers
        function muLawEncodeSample(x) { const MU = 255; const s = Math.max(-1, Math.min(1, x)); const sign = s < 0 ? 0x80 : 0x00; const mag = Math.log1p(MU * Math.abs(s)) / Math.log1p(MU); return (sign | Math.floor(mag * 127)) & 0xFF; }
        function muLawDecodeByte(b) { const MU = 255; const sign = (b & 0x80) ? -1 : 1; const y = (b & 0x7F) / 127; const mag = (Math.pow(1 + MU, y) - 1) / MU; return sign * mag; }

        // ── PCM/μ-law capture via ScriptProcessor (resample to selected sr)
        let pcmActive = false, pcmState = null;
        function configPcmState() {
            const sr = parseInt(aRate?.value || '16000', 10), ms = parseInt(aMs?.value || '40', 10);
            return { outRate: sr, frameSamples: Math.max(80, Math.round(sr * ms / 1000)), acc: [], resPos: 0 };
        }
        async function startPcmPipeline() {
            if (pcmActive) return true;
            try { if (!micStream) micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false }); }
            catch { alert('Microphone access denied'); return false; }
            ensureAudioCtx(); try { await audioCtx.resume(); } catch { }
            micSource = audioCtx.createMediaStreamSource(micStream);
            const bufSize = 2048;
            const node = audioCtx.createScriptProcessor(bufSize, 1, 1);
            pcmState = configPcmState();
            node.onaudioprocess = (ev) => {
                const inBuf = ev.inputBuffer.getChannelData(0), inRate = audioCtx.sampleRate;
                const step = inRate / pcmState.outRate;
                let pos = pcmState.resPos || 0;
                const out = [];
                for (; pos < inBuf.length; pos += step) {
                    const idx = Math.floor(pos), frac = pos - idx;
                    const s0 = inBuf[idx] || 0, s1 = inBuf[idx + 1] || s0;
                    out.push(s0 + (s1 - s0) * frac);
                }
                pcmState.resPos = pos - inBuf.length;
                pcmState.acc.push(...out);
                while (pcmState.acc.length >= pcmState.frameSamples) {
                    const frame = pcmState.acc.splice(0, pcmState.frameSamples);
                    const fmt = aFmt?.value || 'mulaw8';
                    let bytes;
                    if (fmt === 'mulaw8') {
                        const u8 = new Uint8Array(frame.length);
                        for (let i = 0; i < frame.length; i++) u8[i] = muLawEncodeSample(frame[i]);
                        bytes = u8;
                    } else { // pcm16
                        const u8 = new Uint8Array(frame.length * 2);
                        let o = 0;
                        for (let i = 0; i < frame.length; i++) {
                            let s = Math.max(-1, Math.min(1, frame[i]));
                            s = s < 0 ? s * 0x8000 : s * 0x7FFF;
                            const v = s | 0;
                            u8[o++] = v & 0xFF; u8[o++] = (v >> 8) & 0xFF;
                        }
                        bytes = u8;
                    }
                    const b64 = btoa(String.fromCharCode(...bytes));
                    latestAudio = { fmt, sr: pcmState.outRate, bytes: bytes.byteLength, b64, ts: now() };
                    a_sizeEMA = a_sizeEMA == null ? bytes.byteLength : 0.85 * a_sizeEMA + 0.15 * bytes.byteLength;
                    a_srcFps++;
                }
            };
            micSource.connect(node); node.connect(audioCtx.destination);
            procNode = node; pcmActive = true; return true;
        }
        function stopPcmPipeline() { if (procNode) { try { procNode.disconnect(); } catch { } procNode = null; } pcmActive = false; pcmState = null; }

        // ── Opus capture via MediaRecorder
        let opusActive = false, opusRec = null;
        async function startOpusPipeline() {
            if (opusActive) return true;
            if (!opusSupported) { alert('Opus not supported in this browser'); return false; }
            try { if (!micStream) micStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false }); }
            catch { alert('Microphone access denied'); return false; }
            const timeslice = parseInt(aMs?.value || '40', 10);
            opusRec = new MediaRecorder(micStream, { mimeType: 'audio/webm;codecs=opus', audioBitsPerSecond: 32000 });
            opusRec.ondataavailable = async (ev) => {
                if (!ev.data || !ev.data.size) return;
                const buf = new Uint8Array(await ev.data.arrayBuffer());
                latestOpus = { fmt: 'opus', sr: 48000, bytes: buf.byteLength, bin: buf, ts: now() };
                a_sizeEMA = a_sizeEMA == null ? buf.byteLength : 0.85 * a_sizeEMA + 0.15 * buf.byteLength;
                a_srcFps++;
            };
            opusRec.start(timeslice); opusActive = true; return true;
        }
        function stopOpusPipeline() { if (opusRec && opusRec.state !== 'inactive') { try { opusRec.stop(); } catch { } } opusRec = null; opusActive = false; latestOpus = null; }

        // ── Start / ensure local audio
        async function ensureLocalAudio() {
            const fmt = aFmt?.value || 'mulaw8';
            if (fmt === 'opus') return startOpusPipeline();
            return startPcmPipeline();
        }

        // ── Per-peer audio TX (JSON, base64 payload)
        const streamsOutA = new Map(); // pub -> {inFlight,pending,lastTsSent,sent,sizeEMA,timer}
        function ensureSenderA(pub) { if (streamsOutA.has(pub)) return streamsOutA.get(pub); const s = { inFlight: false, pending: false, lastTsSent: 0, sent: 0, sizeEMA: null, timer: null }; streamsOutA.set(pub, s); return s; }
        async function pumpPeerA(pub) {
            const st = streamsOutA.get(pub); if (!st) return;
            const fmt = aFmt?.value || 'mulaw8';
            let frameObj = null;
            if (fmt === 'opus') {
                if (!latestOpus || latestOpus.ts <= st.lastTsSent) return;
                frameObj = latestOpus;
            } else {
                if (!latestAudio || latestAudio.ts <= st.lastTsSent) return;
                frameObj = latestAudio;
            }
            if (st.inFlight) { st.pending = true; return; }
            st.inFlight = true; st.pending = false;

            let payload;
            if (fmt === 'opus') {
                const b64 = btoa(String.fromCharCode(...frameObj.bin));
                payload = JSON.stringify({ ver: 1, type: 'audio_frame', id: `af|${selfPub}|${frameObj.ts}`, from: selfPub, to: pub, ts: frameObj.ts, sr: 48000, fmt: 'opus', b64 });
            } else {
                payload = JSON.stringify({ ver: 1, type: 'audio_frame', id: `af|${selfPub}|${frameObj.ts}`, from: selfPub, to: pub, ts: frameObj.ts, sr: frameObj.sr, fmt: frameObj.fmt, b64: frameObj.b64 });
            }
            const ok = await sendToBest(pub, payload).catch(() => false);
            st.inFlight = false;
            if (ok) {
                st.lastTsSent = frameObj.ts;
                st.sent = (st.sent || 0) + 1;
                const sz = frameObj.bytes;
                st.sizeEMA = st.sizeEMA == null ? sz : 0.85 * st.sizeEMA + 0.15 * sz;
                a_totalSent++;
            } else {
                a_totalDrop++;
            }
            if (st.pending) pumpPeerA(pub);
        }
        function startAudioTo(pub) {
            if (streamsOutA.has(pub)) return;
            ensureSenderA(pub);
            sendToBest(pub, JSON.stringify({ ver: 1, type: 'audio_offer', id: `aof|${selfPub}|${now()}`, from: selfPub, to: pub, ts: now() })).catch(() => { });
            streamsOutA.get(pub).timer = setInterval(() => pumpPeerA(pub), 15);
        }
        function stopAudioTo(pub) {
            const st = streamsOutA.get(pub); if (!st) return;
            clearInterval(st.timer); streamsOutA.delete(pub);
        }



        // ───────────────────────────────── Incoming audio playback
        // PCM/μ-law path
        const rxAudioPCM = new Map(); // pub -> {nextTime}
        function playPcmFrame(pub, sr, fmt, u8) {
            ensureAudioCtx();
            const n = fmt === 'mulaw8' ? u8.length : (u8.length >> 1);
            const buf = audioCtx.createBuffer(1, n, sr);
            const ch = buf.getChannelData(0);
            if (fmt === 'mulaw8') {
                for (let i = 0; i < n; i++) ch[i] = muLawDecodeByte(u8[i]);
            } else { // pcm16le
                for (let i = 0, o = 0; i < n; i++, o += 2) {
                    const v = (u8[o] | (u8[o + 1] << 8));
                    const s = (v & 0x8000) ? v - 0x10000 : v;
                    ch[i] = s / 0x8000;
                }
            }
            const st = rxAudioPCM.get(pub) || { nextTime: audioCtx.currentTime + 0.08 };
            const when = Math.max(audioCtx.currentTime + 0.04, st.nextTime);
            const src = audioCtx.createBufferSource(); src.buffer = buf; src.connect(audioCtx.destination); src.start(when);
            st.nextTime = when + (n / sr);
            rxAudioPCM.set(pub, st);
        }

        // Opus path via MediaSource
        const rxOpus = new Map(); // pub -> {audio, mse, sb, queue:[], open:boolean}
        function ensureOpusSink(pub) {
            if (rxOpus.has(pub)) return rxOpus.get(pub);
            const audio = new Audio(); audio.autoplay = true; audio.controls = false; audio.muted = false; audio.style.display = 'none';
            document.body.appendChild(audio);
            const mse = new MediaSource();
            const sink = { audio, mse, sb: null, queue: [], open: false };
            audio.src = URL.createObjectURL(mse);
            mse.addEventListener('sourceopen', () => {
                try {
                    sink.sb = mse.addSourceBuffer('audio/webm; codecs=opus');
                    sink.open = true; sink.sb.mode = 'sequence';
                    sink.sb.addEventListener('updateend', () => {
                        if (sink.queue.length && !sink.sb.updating) {
                            const chunk = sink.queue.shift();
                            sink.sb.appendBuffer(chunk);
                        }
                    });
                } catch (e) { console.warn('Opus SB error:', e); }
            });
            rxOpus.set(pub, sink);
            audio.play().catch(() => { });
            return sink;
        }
        function playOpusChunk(pub, u8) {
            if (!opusSupported) return;
            const sink = ensureOpusSink(pub);
            if (!sink.open || !sink.sb) return;
            if (sink.sb.updating || sink.queue.length) { sink.queue.push(u8); }
            else { try { sink.sb.appendBuffer(u8); } catch { } }
        }



        /* ====== per-peer TX state + adaptive pacing ====== */
        const streamsOut = new Map(); // pub -> {inFlight,pending,sent,sizeEMA,ack{winSent,winAck,lastAckAt,e2eEma},fpsTick,txCountSec,txFps,lastSentAt}
        function startStreamingTo(pub) {
            if (streamsOut.has(pub)) return;
            streamsOut.set(pub, {
                inFlight: false, pending: false, sent: 0, sizeEMA: null,
                ack: { winSent: 0, winAck: 0, lastAckAt: 0, e2eEma: null },
                fpsTick: now(), txCountSec: 0, txFps: 0, lastSentAt: 0,
                lastFrameTs: 0,                 // ← new: prevent duplicate sends
                preferredSrc: 'cam'             // ← new: per-peer source
            });
            sendToBest(pub, JSON.stringify({ ver: 1, type: 'video_offer', id: `vof|${selfPub}|${now()}`, from: selfPub, to: pub, ts: now() })).catch(() => { });
            sendLatestToPeer(pub); updatePeerUI(pub);
        }

        function stopStreamingTo(pub) { streamsOut.delete(pub); updatePeerUI(pub); }

        function perPeerIntervalMs(pub) {
            const st = streamsOut.get(pub);
            const baseMs = 1000 / parseInt(fpsSlider?.value || '18', 10);
            if (!st || !st.ack) return baseMs;
            const bias = parseFloat(biasSlider?.value || '0.7'); // 0 = ignore e2e, 1 = strongly pace
            const e2e = st.ack.e2eEma ?? 120; // ms
            // Normalize e2e into [0..~1.5] (90ms → 0, 600ms → 1)
            const norm = Math.max(0, Math.min(1.5, (e2e - 90) / 510));
            const factor = 1 + bias * norm; // 1..2.5x
            return baseMs * factor;
        }

        async function sendLatestToPeer(pub) {
            const st = streamsOut.get(pub); if (!st) return;

            // choose per-peer source
            const L = (st.preferredSrc === 'screen' && latestVF2_SS) ? latestVF2_SS : latestVF2;
            if (!L) return;

            // prevent resending identical frame when other encoder ticks
            if (st.lastFrameTs === (L.ts | 0)) { st.pending = false; return; }

            const nowMs = now();
            if (nowMs - st.lastSentAt < perPeerIntervalMs(pub)) { st.pending = true; return; }
            if (st.inFlight) { st.pending = true; return; }
            st.inFlight = true; st.pending = false;

            const ok = await sendToBest(pub, L.packed).catch(() => false);
            st.inFlight = false; st.lastSentAt = nowMs;

            if (ok) {
                st.lastFrameTs = L.ts | 0;
                st.sent++; st.ack.winSent++; totalSent++;
                st.sizeEMA = st.sizeEMA == null ? L.bytes : 0.85 * st.sizeEMA + 0.15 * L.bytes;
                st.txCountSec++; const t = now(); if (t - st.fpsTick >= 1000) { st.txFps = st.txCountSec; st.txCountSec = 0; st.fpsTick = t; }
            } else {
                totalDropped++;
            }
            if (st.pending) sendLatestToPeer(pub);
            updatePeerUI(pub);
        }


        /* ====== RX sinks + fast decode + ACK ====== */
        const incomingSinks = new Map(); // pub -> {holder,canvas,ctx,w,h}
        function ensureSink(pub) {
            let s = incomingSinks.get(pub);
            const tile = document.querySelector(`.peer[data-pub="${pub}"]`);
            if (!tile) return null;
            let holder = tile.querySelector('.preview');
            if (!holder) { return null; }
            if (s && s.canvas && s.canvas.isConnected) { return s; }
            const c = document.createElement('canvas'); c.width = 320; c.height = 240; const ctx = c.getContext('2d', { alpha: false });
            holder.replaceChildren(c);
            s = { holder, canvas: c, ctx, w: 320, h: 240 }; incomingSinks.set(pub, s); return s;
        }
        function setAspect(holder, w, h) {
            if (holder && 'aspectRatio' in holder.style) holder.style.aspectRatio = `${w} / ${h}`;
        }

        async function decodeU8ToDrawable(u8, mime) {
            try {
                if ('ImageDecoder' in window) {
                    const ab = u8.buffer.slice(u8.byteOffset, u8.byteOffset + u8.byteLength);
                    const dec = new ImageDecoder({ data: ab, type: mime });
                    const { image } = await dec.decode();
                    return { type: 'bitmap', bmp: image, w: image.codedWidth || image.displayWidth, h: image.codedHeight || image.displayHeight, close: () => image.close() };
                }
            } catch { }
            try {
                if ('createImageBitmap' in window) {
                    const bmp = await createImageBitmap(new Blob([u8], { type: mime }));
                    return { type: 'bitmap', bmp, w: bmp.width, h: bmp.height, close: () => bmp.close && bmp.close() };
                }
            } catch { }
            const url = URL.createObjectURL(new Blob([u8], { type: mime }));
            const img = new Image(); img.src = url; await img.decode(); URL.revokeObjectURL(url);
            return { type: 'img', img, w: img.naturalWidth, h: img.naturalHeight, close: () => { } };
        }

        const rxState = new Map(); // pub -> {decoding,queued,lastAckSent,lastSeenSeq,rxFps,rxTick,rxCount}
        async function processQueue(pub) {
            const st = rxState.get(pub) || { decoding: false, queued: null, lastAckSent: 0, lastSeenSeq: 0, rxFps: 0, rxTick: now(), rxCount: 0 };
            if (st.decoding || !st.queued) return;
            st.decoding = true; rxState.set(pub, st);
            const job = st.queued; st.queued = null;
            try {
                const mime = VF2.mimeFromCode(job.fmtCode);
                const drawable = await decodeU8ToDrawable(job.u8, mime);
                const w = job.w || drawable.w, h = job.h || drawable.h;
                const sink = ensureSink(pub); if (!sink) { drawable.close(); st.decoding = false; rxState.set(pub, st); return; }
                setAspect(sink.holder, w, h);
                if (sink.canvas.width !== w || sink.canvas.height !== h) { sink.canvas.width = w; sink.canvas.height = h; }
                if (drawable.type === 'bitmap') sink.ctx.drawImage(drawable.bmp, 0, 0, w, h); else sink.ctx.drawImage(drawable.img, 0, 0, w, h);
                drawable.close();
                st.rxCount++; const t = now(); if (t - st.rxTick >= 1000) { st.rxFps = st.rxCount; st.rxCount = 0; st.rxTick = t; }
            } catch { } finally {
                st.decoding = false; rxState.set(pub, st);
                if (st.queued) processQueue(pub);
            }
            // coalesced ACK by time/seq (tighter for latency)
            st.lastSeenSeq = Math.max(st.lastSeenSeq, job.seq | 0);
            const nowMs = now();
            if (nowMs - (st.lastAckSent || 0) > 120) {
                st.lastAckSent = nowMs;
                sendToBest(pub, JSON.stringify({ ver: 1, type: 'video_ack', id: `vack|${selfPub}|${st.lastSeenSeq}`, from: selfPub, to: pub, ts: nowMs, ackSeq: st.lastSeenSeq })).catch(() => { });
            }
            updatePeerUI(pub);
        }

        function onBinaryFrame(fromPub, u8) {
            const f = VF2.parse(u8); if (!f) return;
            const pub = fromPub.toLowerCase();
            ensurePeer(pub, { ts: now(), vestigial: false, addr: bestAddrForPub(pub) || `web.${pub}` });
            let st = rxState.get(pub); if (!st) { st = { decoding: false, queued: null, lastAckSent: 0, lastSeenSeq: 0, rxFps: 0, rxTick: now(), rxCount: 0 }; rxState.set(pub, st); }
            st.queued = { fmtCode: f.fmtCode, u8: f.payload, w: f.w | 0, h: f.h | 0, ts: f.ts | 0, seq: f.seq | 0 };
            processQueue(pub);
        }

        /* ====== Peer tiles (grid) ====== */
        const grid = $('#grid');
        function ensurePeerTile(pub) {
            // ensure styles exist (green=on, red=off)
            if (!document.getElementById('avToggleStyles')) {
                const st = document.createElement('style');
                st.id = 'avToggleStyles';
                st.textContent = `
      .avToggles{display:flex;gap:8px}
      .iconBtn{
        height:32px;padding:0 10px;border:1px solid #333;border-radius:8px;
        background: var(--bg); color:#fff; cursor:pointer
      }
      .iconBtn.on{ background: var(--fg); color:#000; }
    `;
                document.head.appendChild(st);
            }

            let tile = document.querySelector(`.peer[data-pub="${pub}"]`);
            if (tile) return tile;

            tile = document.createElement('div');
            tile.className = 'peer';
            tile.dataset.pub = pub;

            // Frame + overlays
            const frame = document.createElement('div');
            frame.className = 'frame';
            frame.title = 'Click to start/stop sending your stream';

            const overlayTop = document.createElement('div');
            overlayTop.className = 'overlay top';

            const leftTop = document.createElement('div');
            leftTop.style.display = 'flex';
            leftTop.style.alignItems = 'center';
            leftTop.style.gap = '6px';

            const dot = document.createElement('span');
            dot.className = 'dot warn';

            const addr = document.createElement('span');
            addr.className = 'addr mono';
            addr.textContent = shortHex(pub, 8, 6);

            leftTop.appendChild(dot);
            leftTop.appendChild(addr);

            const rightTop = document.createElement('div');
            rightTop.style.display = 'flex';
            rightTop.style.gap = '6px';
            rightTop.style.alignItems = 'center';

            const txBadge = document.createElement('span');
            txBadge.className = 'chip tx';
            txBadge.textContent = 'TX';
            txBadge.hidden = true;

            rightTop.appendChild(txBadge);

            overlayTop.appendChild(leftTop);
            overlayTop.appendChild(rightTop);

            const preview = document.createElement('div');
            preview.className = 'preview';

            const overlayBottom = document.createElement('div');
            overlayBottom.className = 'overlay bottom';

            const meta = document.createElement('div');
            meta.className = 'meta tiny';
            meta.textContent = '—';

            overlayBottom.appendChild(meta);

            frame.appendChild(overlayTop);
            frame.appendChild(preview);
            frame.appendChild(overlayBottom);

            // ===== Bottom row (controls)
            const row = document.createElement('div');
            row.className = 'row';

            const avTog = document.createElement('div');
            avTog.className = 'avToggles';

            const btnMic = document.createElement('button');
            btnMic.className = 'iconBtn';
            btnMic.title = 'Toggle audio TX';
            btnMic.textContent = '🎤';

            const btnCam = document.createElement('button');
            btnCam.className = 'iconBtn';
            btnCam.title = 'Toggle video TX';
            btnCam.textContent = '📷';

            const btnShare = document.createElement('button');
            btnShare.className = 'iconBtn ss';
            btnShare.title = 'Use screen share instead of camera';
            btnShare.textContent = '🖥️';

            // Initial on/off color
            btnMic.classList.toggle('on', streamsOutA.has(pub));
            btnCam.classList.toggle('on', streamsOut.has(pub));
            btnShare.classList.toggle('on', (streamsOut.get(pub)?.preferredSrc === 'screen'));

            // NEW: Per-peer screen share toggle
            btnShare.addEventListener('click', async (e) => {
                e.stopPropagation();

                // ensure there's a video TX state to attach source to
                if (!streamsOut.has(pub)) {
                    await ensureCamStream();
                    startStreamingTo(pub);
                }
                const st = streamsOut.get(pub);

                if (st.preferredSrc !== 'screen') {
                    const ok = await startScreenShare();
                    if (!ok) return;
                    st.preferredSrc = 'screen';
                    btnShare.classList.add('on');
                } else {
                    st.preferredSrc = 'cam';
                    btnShare.classList.remove('on');
                    maybeStopScreenWhenUnused(); // shuts screen capture if nobody uses it
                }
                updatePeerUI(pub);
            });


            avTog.appendChild(btnMic);
            avTog.appendChild(btnCam);
            avTog.appendChild(btnShare);
            row.appendChild(avTog);

            // Add to grid
            tile.appendChild(frame);
            tile.appendChild(row);
            grid.appendChild(tile);

            // ===== Click handlers =====

            // Default click: toggle BOTH audio+video together
            frame.addEventListener('click', async (e) => {
                e.stopPropagation();
                const sendingV = streamsOut.has(pub);
                const sendingA = streamsOutA.has(pub);
                if (!sendingV && !sendingA) {
                    await ensureCamStream();
                    await ensureLocalAudio(); try { if (audioCtx) await audioCtx.resume(); } catch { }
                    startStreamingTo(pub);
                    startAudioTo(pub);
                    btnCam.classList.add('on');
                    btnMic.classList.add('on');
                    txBadge.hidden = false;
                } else {
                    if (sendingV) { stopStreamingTo(pub); btnCam.classList.remove('on'); }
                    if (sendingA) { stopAudioTo(pub); btnMic.classList.remove('on'); }
                    txBadge.hidden = !streamsOut.has(pub);
                }
                updatePeerUI(pub);
            });

            // Mini toggles (independent)
            btnMic.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (!streamsOutA.has(pub)) {
                    await ensureLocalAudio(); try { if (audioCtx) await audioCtx.resume(); } catch { }
                    startAudioTo(pub);
                    btnMic.classList.add('on');
                } else {
                    stopAudioTo(pub);
                    btnMic.classList.remove('on');
                }
                updatePeerUI(pub);
            });

            btnCam.addEventListener('click', async (e) => {
                e.stopPropagation();
                if (!streamsOut.has(pub)) {
                    await ensureCamStream();
                    startStreamingTo(pub);
                    btnCam.classList.add('on');
                    txBadge.hidden = false;
                } else {
                    stopStreamingTo(pub);
                    btnCam.classList.remove('on');
                    txBadge.hidden = true;
                }
                updatePeerUI(pub);
            });

            return tile;
        }



        function peerMetaText(pub) { const ent = peers.get(pub) || {}; const ago = ent.lastTs ? fmtAgo(now() - ent.lastTs) + ' ago' : '—'; return ent.isVestigial ? `last seen ${ago}` : `active • ${ago}`; }
        function updatePeerUI(pub) {
            const tile = document.querySelector(`.peer[data-pub="${pub}"]`); if (!tile) return;
            const addrEl = tile.querySelector('.addr'); if (addrEl) addrEl.textContent = shortHex(pub, 8, 6);
            const nameEl = tile.querySelector('.name'); if (nameEl) nameEl.textContent = shortHex(pub, 8, 6);

            const st = streamsOut.get(pub) || null;
            const rx = rxState.get(pub) || null;
            const isOnlineNow = isPeerOnline(pub);

            // dots (keep your blink-on-video if you added it)
            const dotEls = tile.querySelectorAll('.dot');
            const baseClass = 'dot ' + (isOnlineNow ? 'ok' : (peers.get(pub)?.isVestigial ? 'err' : 'warn'));
            const blink = st ? ' blink' : '';
            dotEls.forEach(d => d.className = baseClass + blink);

            const txFps = st ? (st.txFps || 0) : 0;
            const rxFps = rx ? (rx.rxFps || 0) : 0;
            const avgKB = st?.sizeEMA != null ? Math.round(st.sizeEMA / 1024) : 0;
            const ackPct = st && st.ack ? (st.ack.winSent ? Math.round((st.ack.winAck / st.ack.winSent) * 100) : 0) : 0;

            const meta = tile.querySelector('.meta');
            if (meta) meta.textContent = `${peerMetaText(pub)} • tx ${txFps}fps • rx ${rxFps}fps • ~${avgKB}KB • ack ${ackPct}%`;

            const txBadge = tile.querySelector('.tx'); if (txBadge) txBadge.hidden = !st;

            // ── NEW: reflect buttons
            const btnMic = tile.querySelector('.iconBtn:nth-child(1)');
            const btnCam = tile.querySelector('.iconBtn:nth-child(2)');
            if (btnMic) btnMic.classList.toggle('on', streamsOutA.has(pub));
            if (btnCam) btnCam.classList.toggle('on', streamsOut.has(pub));
            const btnShare = tile.querySelector('.iconBtn.ss');
            if (btnShare) btnShare.classList.toggle('on', streamsOut.get(pub)?.preferredSrc === 'screen');

        }


        setInterval(() => { for (const [pub] of peers.entries()) updatePeerUI(pub); }, 1200);

        /* ====== NKN wiring (binary aware) ====== */
        let SEND_GUARD = true; // simple guard to avoid send before connected
        async function connectNkn() {
            try {
                setNkn('NKN: connecting…', 'warn');
                const seed = getOrCreateSeed();
                client = new window.nkn.MultiClient({ seed, identifier: 'web', numSubClients: 8, originalClient: true });

                client.onConnect(() => {
                    selfAddr = client.addr || null; selfPub = client.getPublicKey() || null;
                    $('#myAddr') && ($('#myAddr').textContent = selfAddr || '—');
                    setNkn('NKN: connected', 'ok'); scheduleHB(); scheduleTicks(); probeAll();
                    for (const to of targets()) rawSend(to, JSON.stringify({ ver: 1, type: 'peers_req', id: `peers_req|${selfPub}|${now()}`, from: selfPub, ts: now() })).catch(() => { });
                    ensureCamStream().catch(() => { });
                    SEND_GUARD = false;
                });

                client.onMessage(async ({ src, payload }) => {
                    if (src) {
                        const m = /^([a-z0-9_-]+)\.([0-9a-f]{64})$/i.exec(src);
                        if (m) { idSet(m[2].toLowerCase()).add(m[1]); persistKnownIds(); poolAdd(src, now()); ensurePeer(m[2].toLowerCase(), { addr: src, ts: now() }); }
                        else { poolAdd(src, now()); }
                    }

                    // BINARY (VF2)
                    if (payload instanceof Uint8Array && payload.length >= 3 && payload[0] === VF2.MAGIC0 && payload[1] === VF2.MAGIC1 && payload[2] === VF2.MAGIC2) {
                        const pub = (src?.split('.')?.pop() || '').toLowerCase();
                        if (pub) onBinaryFrame(pub, payload);
                        return;
                    }

                    // JSON path
                    let text = payload;
                    if (payload instanceof Uint8Array) {
                        try { text = new TextDecoder().decode(payload); } catch { return; }
                    }
                    if (typeof text !== 'string') return;
                    let msg = null; if (text.trim().startsWith('{')) { try { msg = JSON.parse(text); } catch { } }
                    const tsNow = now(); if (!msg) return; if (markSeen(msg)) return;

                    if (msg.type === 'hb') { rawSend(src, JSON.stringify({ ver: 1, type: 'hb_ack', id: msg.id || `hb_ack|${selfPub}|${tsNow}`, from: selfPub, t_client: msg.t_client })).catch(() => { }); if (msg.from) ensurePeer(msg.from.toLowerCase(), { ts: tsNow }); return; }
                    if (msg.type === 'hb_ack' && typeof msg.t_client === 'number') { const rtt = Math.max(0, tsNow - (msg.t_client || tsNow)); poolNoteAck(src, rtt); if (msg.from) { ensurePeer(msg.from.toLowerCase(), { ts: tsNow }); } return; }
                    if (msg.type === 'tick') { if (msg.from) ensurePeer(msg.from.toLowerCase(), { ts: tsNow }); return; }

                    if (msg.type === 'peers') { const arr = Array.isArray(msg.items) ? msg.items : []; for (const it of arr) { const pub = (it.pub || '').toLowerCase(); if (!pub || pub === (selfPub || '').toLowerCase()) continue; const ids = idSet(pub); (Array.isArray(it.ids) ? it.ids : []).forEach(id => ids.add(id)); ids.forEach(id => poolAdd(`${id}.${pub}`, tsNow)); const addrGuess = it.addr || (ids.size ? `${[...ids][0]}.${pub}` : `web.${pub}`); poolAdd(addrGuess, tsNow); ensurePeer(pub, { addr: addrGuess, ts: typeof it.last === 'number' ? it.last : tsNow, vestigial: !!it.vestigial }); } persistKnownIds(); return; }
                    if (msg.type === 'peers_req') { const roster = { ver: 1, type: 'peers', id: `peers|${selfPub}|${now()}`, ts: now(), items: [...peers.entries()].map(([pub, ent]) => ({ pub, ids: [...idSet(pub)], addr: ent.addr || `web.${pub}`, last: ent.lastTs || 0, vestigial: !!ent.isVestigial })) }; rawSend(src, JSON.stringify(roster)).catch(() => { }); return; }

                    if (msg.type === 'join') { const ack = { ver: 1, type: 'joined', id: `joined|${selfPub}|${tsNow}`, ts: tsNow, addr: selfAddr, prefix: 'peer' }; sendToBest(msg.from, JSON.stringify(ack)).catch(() => { }); const from = msg.from?.toLowerCase(); if (from) ensurePeer(from, { ts: tsNow }); return; }
                    if (msg.type === 'joined') { poolNoteAck(src, null); return; }
                    if (msg.type === 'leave' && msg.from) { const from = msg.from.toLowerCase(); const ent = peers.get(from) || {}; ensurePeer(from, { ts: tsNow, vestigial: true, addr: ent.addr || `web.${from}` }); return; }

                    if (msg.type === 'video_offer' && msg.from && (!msg.to || msg.to === selfPub)) { const ack = { ver: 1, type: 'video_accept', id: `vack|${selfPub}|${tsNow}`, from: selfPub, to: msg.from, ts: tsNow }; sendToBest(msg.from, JSON.stringify(ack)).catch(() => { }); return; }
                    if (msg.type === 'video_accept' && msg.from && msg.to === selfPub) { return; }

                    // Legacy JSON frame path (compat)
                    if (msg.type === 'video_frame' && msg.from && msg.b64 && (msg.fmt === 'jpeg' || msg.fmt === 'webp')) {
                        const mime = (msg.fmt === 'webp') ? 'image/webp' : 'image/jpeg';
                        const bin = atob(msg.b64); const u8 = new Uint8Array(bin.length); for (let i = 0; i < bin.length; i++) u8[i] = bin.charCodeAt(i);
                        const pub = msg.from.toLowerCase();
                        ensurePeer(pub, { ts: now(), vestigial: false, addr: bestAddrForPub(pub) || `web.${pub}` });
                        let st = rxState.get(pub); if (!st) { st = { decoding: false, queued: null, lastAckSent: 0, lastSeenSeq: 0, rxFps: 0, rxTick: now(), rxCount: 0 }; rxState.set(pub, st); }
                        st.queued = { fmtCode: (mime === 'image/jpeg') ? VF2.FMT_JPEG : VF2.FMT_WEBP, u8, w: msg.w | 0, h: msg.h | 0, ts: msg.ts | 0, seq: (msg.seq | 0) || 0 };
                        processQueue(pub);
                        return;
                    }

                    if (msg.type === 'video_ack' && msg.from && msg.to === selfPub) {
                        const from = msg.from.toLowerCase();
                        const st = streamsOut.get(from); if (!st) return;
                        const ackSeq = (msg.ackSeq | 0) || 0;
                        if (ackSeq > 0) {
                            st.ack.winAck++; st.ack.lastAckAt = now();
                            const e2e = now() - ackSeq;
                            st.ack.e2eEma = st.ack.e2eEma == null ? e2e : 0.8 * st.ack.e2eEma + 0.2 * e2e;
                            updatePeerUI(from);
                        } else if (typeof msg.srcTs === 'number') { // legacy
                            st.ack.winAck++; st.ack.lastAckAt = now(); const e2e = now() - msg.srcTs; st.ack.e2eEma = st.ack.e2eEma == null ? e2e : 0.8 * st.ack.e2eEma + 0.2 * e2e; updatePeerUI(from);
                        }
                        return;
                    }
                    // ── Audio handshakes / frames (JSON, base64)
                    if (msg.type === 'audio_offer' && msg.from && (!msg.to || msg.to === selfPub)) {
                        const ack = { ver: 1, type: 'audio_accept', id: `aack|${selfPub}|${now()}`, from: selfPub, to: msg.from, ts: now() };
                        sendToBest(msg.from, JSON.stringify(ack)).catch(() => { });
                        // optionally auto-start capture on accept path
                        return;
                    }
                    if (msg.type === 'audio_accept' && msg.from && msg.to === selfPub) {
                        const ok = await ensureLocalAudio(); if (ok) { try { if (audioCtx) await audioCtx.resume(); } catch { } startAudioTo(msg.from); }
                        return;
                    }
                    if (msg.type === 'audio_frame' && msg.from && msg.b64 && msg.fmt) {
                        const from = msg.from.toLowerCase();
                        ensurePeer(from, { ts: now() });
                        if (msg.fmt === 'opus') {
                            if (opusSupported) {
                                const u8 = Uint8Array.from(atob(msg.b64), c => c.charCodeAt(0));
                                playOpusChunk(from, u8);
                            }
                        } else {
                            const u8 = Uint8Array.from(atob(msg.b64), c => c.charCodeAt(0));
                            playPcmFrame(from, msg.sr | 0, msg.fmt, u8);
                        }
                        return;
                    }

                });

                client.on('error', () => setNkn('NKN: error', 'err'));
                client.on('connectFailed', () => setNkn('NKN: connect failed (retrying)', 'warn'));
                client.on('willreconnect', () => setNkn('NKN: reconnecting…', 'warn'));
                client.on('close', () => setNkn('NKN: disconnected', 'err'));
            } catch { setNkn('NKN: init failed', 'err'); }
        }

        /* ====== dedupe for JSON msgs ====== */
        const seenIds = new Map(); setInterval(() => { const cut = now() - 120000; for (const [id, ts] of seenIds.entries()) if (ts < cut) seenIds.delete(id); }, 15000);
        function markSeen(msg) { const id = (msg && typeof msg.id === 'string') ? msg.id : `${msg?.type || '?'}|${msg?.from || '?'}|${msg?.ts || 0}`; const t = now(); const prev = seenIds.get(id); if (prev && (t - prev) < 60000) return true; seenIds.set(id, t); return false; }

        /* ====== signaller override + start ====== */
        function applySignallerHex(raw) {
            const v = (raw || '').trim().toLowerCase();
            signallerHex = isHex64(v) ? v : DEFAULT_SIG_HEX;
            if (isHex64(v)) localStorage.setItem(LS.SIGHEX, v);
            signallerPrefix = 'signal';
            const primary = `${signallerPrefix}.${signallerHex}`;
            poolAdd(primary, now()); setSig(`Mesh: prim ${shortHex(primary, 7, 6)} + peers`, 'warn'); setSigMeta('probing…');
            probeAll();
        }
        const hexInput = $('#hexSig'); if (hexInput) { hexInput.value = localStorage.getItem(LS.SIGHEX) || ''; hexInput.addEventListener('input', () => applySignallerHex(hexInput.value)); }
        applySignallerHex(hexInput?.value || DEFAULT_SIG_HEX);

        /* ====== join/leave pulses ====== */
        function periodicJoin() {
            if (!client || !client.addr || !selfPub) return;
            const pkt = { ver: 1, type: 'join', id: `join|${selfPub}|${now()}`, from: selfPub, addr: selfAddr, ts: now(), caps: { relay: true, roster: true } };
            for (const to of targets()) rawSend(to, JSON.stringify(pkt)).catch(() => { });
        }
        setInterval(periodicJoin, 15000);
        addEventListener('beforeunload', () => { try { const pkt = { ver: 1, type: 'leave', id: `leave|${selfPub}|${now()}`, from: selfPub, addr: selfAddr, ts: now() }; for (const to of targets()) rawSend(to, JSON.stringify(pkt)).catch(() => { }); } catch { } });

        /* ====== boot ====== */
        connectNkn();
        ensureCamStream().catch(() => { });
        scheduleHB(); scheduleTicks();

        /* ====== optional: self tile for visual consistency ====== */
        // You can comment this out if you don't want a self tile.
        (function addSelfTile() {
            const pub = 'SELF_' + Math.random().toString(36).slice(2, 7);
            const tile = document.createElement('div'); tile.className = 'peer self'; tile.dataset.pub = pub;

            const frame = document.createElement('div'); frame.className = 'frame';
            frame.style.cursor = 'pointer';
            frame.title = 'Tap to toggle front/back camera';
            frame.addEventListener('click', () => toggleFacing());

            const overlayTop = document.createElement('div'); overlayTop.className = 'overlay top';
            overlayTop.innerHTML = `<span class="chip"><span class="addr mono">${shortHex(selfPub || 'you', 6, 6)}</span></span>`;

            const preview = document.createElement('div'); preview.className = 'preview';
            const video = document.querySelector('#localVideo');
            if (video) {
                const ghost = document.createElement('video');
                ghost.muted = true; ghost.playsInline = true; ghost.autoplay = true;
                ghost.style.width = '100%'; ghost.style.height = '100%'; ghost.style.objectFit = 'cover';
                const setSrc = () => { if (video.srcObject) { ghost.srcObject = video.srcObject; ghost.play().catch(() => { }); } else setTimeout(setSrc, 400); };
                setSrc();
                preview.appendChild(ghost);
            }

            const overlayBottom = document.createElement('div'); overlayBottom.className = 'overlay bottom';
            overlayBottom.innerHTML = `<div class="meta tiny">local preview — click to flip camera</div>`;

            frame.appendChild(overlayTop); frame.appendChild(preview); frame.appendChild(overlayBottom);
            const row = document.createElement('div'); row.className = 'row'; row.innerHTML = `<div class="name mono">you</div>`;
            tile.appendChild(frame); tile.appendChild(row);
            grid.prepend(tile);
        })();

    </script>
</body>

</html>
